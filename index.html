<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Album to Video</title>
<style>
  :root{
    --bg:#0c0f14;
    --panel:#121827;
    --panel2:#0f1523;
    --text:#eaf1ff;
    --muted:#9aa8c4;
    --accent:#5aa7ff;
    --accentSoft:#8fc6ff;
    --border:#24314a;
    --danger:#ff6b6b;
    --total:#7fb8ff;
    --pagePad:20px;
    --topbarGap:18px;
    --azGap:16px;
    --azTop:16px;
    --azDividerGap:18px;
    --bottomInset:20px;
    --subSectionGap:clamp(12px, 1.8vh, 18px);
  }
  *{ box-sizing:border-box; }
  html, body{
    height:100%;
    margin:0;
    overflow:hidden;
  }
  body{
    padding:var(--pagePad);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    overflow:hidden;
  }
  .topbar{ display:flex; align-items:flex-start; justify-content:space-between; gap:13px; margin-bottom:var(--topbarGap); }
  .title{ font-size:20px; font-weight:900; letter-spacing:0.2px; }
  .subtitle{ font-size:13px; color:var(--muted); margin-top:6px; max-width:860px; line-height:1.35; }
  .topActions{ display:flex; gap:13px; align-items:center; flex-wrap:wrap; }
  .grid{
    display:grid;
    grid-template-columns: minmax(420px, 1fr) minmax(420px, 1fr);
    gap:24px;
    flex:1 1 auto;
    min-width:0;
    min-height:0;
  }
  .grid > *{
    min-width:0;
    min-height:0;
  }
  .grid > .card:first-child{
    display:flex;
    flex-direction:column;
    min-height:0;
  }
  .grid > .card:last-child{
    display:flex;
    flex-direction:column;
    min-height:0;
  }
  .card{
    background: linear-gradient(180deg, var(--panel), var(--panel2));
    border:1px solid var(--border);
    border-radius:14px;
    padding:24px;
    box-shadow: 0 14px 40px rgba(0,0,0,0.28);
    min-width:0;
  }
  .card h3{
    margin:0 0 13px 0;
    font-size:13px;
    color: var(--muted);
    font-weight:800;
    text-transform:uppercase;
    letter-spacing:0.9px;
  }
  .row{ display:flex; gap:13px; flex-wrap:wrap; margin-top:13px; align-items:center; }
  .row.first{ margin-top:0; }

  .isHidden{ display:none !important; }
  .actionRow{
    flex-wrap:nowrap;
    margin-top:var(--azTop);
  }
  .actionRow #btnOpenFolder{ margin-left:auto; }
  button{
    background: var(--accent);
    color:#04111e;
    border:0;
    border-radius:10px;
    padding:10px 12px;
    font-weight:900;
    cursor:pointer;
    font-size:13px;
  }
  button.secondary{ background: transparent; color: var(--text); border:1px solid var(--border); }
  button.danger{ background: transparent; color: var(--danger); border:1px solid rgba(255,107,107,0.35); }
  button.primary{
    background: linear-gradient(180deg, var(--accentSoft), var(--accent));
    color:#02101e;
    padding:12px 16px;
    border-radius:12px;
    font-size:14px;
    letter-spacing:0.2px;
    box-shadow: 0 10px 22px rgba(90,167,255,0.18);
  }
  button:disabled{ opacity:0.5; cursor:not-allowed; }

  select, input[type="text"]{
    background: transparent;
    color: var(--text);
    border:1px solid var(--border);
    border-radius:10px;
    padding:10px 12px;
    font-weight:900;
    font-size:13px;
    outline:none;
  }
  select{
    width:min(280px, 100%);
    max-width:100%;
    min-width:0;
  }
  option{ color:#000; }

  /* Preset is an intention, not a form: keep it optically compact. */
  .presetBlock{ max-width:280px; align-self:flex-start; }
  .presetBlock #presetDescription{ max-width:280px; }
  #presetDescription{
    color: var(--muted);
    font-size:12px;
    line-height:1.25;
    display:-webkit-box;
    -webkit-line-clamp:2;
    -webkit-box-orient:vertical;
    overflow:hidden;
  }

  .kv{
    margin-top:12px;
    display:grid;
    grid-template-columns: 110px 1fr;
    gap:8px 12px;
    font-size:13px;
    color: var(--muted);
    align-items:center;
    max-width:360px;
  }
  .kv .v{ color: var(--text); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

  .list{
    margin:13px 0 0 0;
    padding:0;
    list-style:none;
    flex:1 1 auto;
    min-height:0;
    overflow-y:auto;
    overflow-x:hidden;
    border:1px solid var(--border);
    border-radius:12px;
    scrollbar-gutter: stable both-edges;
  }
  .list li{
    display:grid;
    grid-template-columns: 1fr 28px;
    align-items:center;
    gap:13px;
    padding:10px 13px;
    border-bottom:1px solid rgba(255,255,255,0.06);
    font-size:13px;
  }
  .list li:last-child{ border-bottom:0; }

  .trackText{ min-width:0; }
  .trackMain{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-weight:900; }
  .trackSub{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; color: var(--muted); font-size:12px; margin-top:2px; }

  .removeBtn{
    width:28px; height:28px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.10);
    background: rgba(255,255,255,0.03);
    color: rgba(255,255,255,0.82);
    display:flex; align-items:center; justify-content:center;
    cursor:pointer;
    user-select:none;
  }
  .removeBtn:hover{
    border-color: rgba(255,107,107,0.4);
    color: var(--danger);
    background: rgba(255,107,107,0.08);
  }
  .removeBtn.disabled{
    opacity:0.4;
    cursor:not-allowed;
    pointer-events:none;
  }

  .inline{ display:flex; align-items:center; gap:13px; flex-wrap:wrap; margin-top:13px; }
  .inline label{ display:flex; align-items:center; gap:8px; color: var(--muted); font-size:13px; font-weight:850; }
  .inline input[type="checkbox"]{ transform: scale(1.05); }
  #releaseFolderSection{
    min-width:240px;
    min-height:42px;
    display:flex;
    align-items:center;
  }
  #releaseFolderSection.dimmed{
    opacity:0.55;
  }
  #releaseFolderSection.dimmed input{
    pointer-events:none;
  }

  .coverPreviewRow{
    display:inline-flex;
    align-items:center;
    gap:12px;
    margin-top:12px;
    padding:12px;
    border:1px solid rgba(255,255,255,0.08);
    border-radius:12px;
    background: rgba(255,255,255,0.02);
    width:auto;
    max-width:320px;
    align-self:flex-start;
  }
  .coverPreview{
    width:88px; height:88px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,0.10);
    background: rgba(255,255,255,0.03);
    overflow:hidden;
    display:flex; align-items:center; justify-content:center;
    flex: 0 0 auto;
    position:relative;
  }
  .coverPreview img{ width:100%; height:100%; object-fit: cover; display:none; }
  .coverPlaceholder{
    color: var(--muted);
    font-weight:800;
    font-size:11px;
    letter-spacing:0.2px;
    text-align:center;
    padding:0;
    line-height:1.2;
    cursor:pointer;
    position:absolute;
    top:50%;
    left:50%;
    transform: translate(-50%, -50%);
    width:100%;
  }
  .coverMeta{ min-width:0; flex: 0 1 auto; }
  /* Keep the label/text optically grouped, without turning into another “panel”. */
  .coverMetaBox{
    border:1px solid rgba(255,255,255,0.07);
    background: rgba(255,255,255,0.018);
    border-radius:10px;
    padding:10px 10px;
    max-width:200px;
    min-width:0;
  }
  .coverMetaTitle{ font-weight:950; font-size:13px; margin-bottom:4px; }
  .coverMetaSub{ color: var(--muted); font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

  .progressWrap{
    border-top:1px solid rgba(255,255,255,0.08);
    padding-top:12px;
  }
  .progressTitle{ font-size:13px; color: var(--muted); margin-bottom:8px; }
  .bar{ position:relative; height:18px; background: rgba(255,255,255,0.09); border-radius:999px; overflow:hidden; width:100%; }
  .fill{ height:100%; width:0%; background: var(--accent); border-radius:999px; transition: width 450ms cubic-bezier(0.22, 1, 0.36, 1); }
  .fill.total{ background: var(--total); opacity:0.9; }
  .barText{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:13px; font-weight:950; color: rgba(234,241,255,0.92); letter-spacing:0.2px; text-shadow: 0 1px 10px rgba(0,0,0,0.55); pointer-events:none; }
  #trackTitle{ display:none; }
  .statusLine{ margin:0 0 8px 0; font-size:13px; color: var(--muted); line-height:1.35; }
  /* Reserve space so "Open output folder" never crushes the progress area in fixed window. */
  .openRow{
    margin-top:10px;
    display:flex;
    align-items:center;
    gap:10px;
    min-height:44px;
  }
  .openRow.hidden{ opacity:0; visibility:hidden; pointer-events:none; }
  .appShell{
    position:relative;
    height:100%;
    display:flex;
    flex-direction:column;
    min-height:0;
    min-width:0;
    overflow:hidden;
  }
  .locked .card{
    opacity:0.78;
    filter: saturate(0.92);
  }
  .toastWrap{
    position:fixed;
    right:18px;
    bottom:18px;
    display:flex;
    flex-direction:column;
    gap:8px;
    z-index:30;
    pointer-events:none;
  }
  .toast{
    background: rgba(15,21,35,0.94);
    border:1px solid var(--border);
    color: var(--text);
    padding:10px 12px;
    border-radius:10px;
    font-size:12px;
    font-weight:700;
    letter-spacing:0.2px;
    box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    opacity:0;
    transform: translateY(6px);
    transition: opacity 0.18s ease, transform 0.18s ease;
  }
  .toast.show{ opacity:1; transform: translateY(0); }
  .toast.warn{ border-color: rgba(255,107,107,0.35); color: var(--danger); }
  .toast.info{ border-color: rgba(90,167,255,0.35); color: var(--accentSoft); }

  /* --- Settings panel optical balance (UI-only, fixed-window safe) --- */
  .settingsCard .row{ margin-top:10px; }
  .settingsCard .row.first{ margin-top:0; }
  .settingsCard .subSection{ margin-top:var(--subSectionGap); }
  .settingsCard .inline{ margin-top:10px; gap:12px; }
  .settingsCard .kv{ margin-top:calc(var(--subSectionGap) - 2px); }
  .settingsCard .actionRow{ margin-top:calc(var(--bottomInset) - 8px); }
  .settingsCard select{ width:min(240px, 100%); }
  .settingsCard #releaseFolderSection{ min-width:0; }
  .settingsCard #albumName{ width:210px; }
  .settingsCard .actionZone{ padding-bottom:0; }
  .settingsCard .progressWrap{
    border-top:1px solid rgba(255,255,255,0.08);
    padding-top:12px;
    padding-bottom:0;
  }
  .settingsCard .actionZone .progressWrap{ margin-top:calc(var(--azDividerGap) - var(--azGap) + 4px); }
  .settingsCard .statusLine{ margin:0 0 6px 0; }

  .actionZone{
    margin-top:var(--subSectionGap);
    display:flex;
    flex-direction:column;
    gap:var(--azGap);
  }
  .actionZone .progressWrap{ margin-top:calc(var(--azDividerGap) - var(--azGap)); }

</style>
</head>
<body>

<div class="appShell">
<div class="topbar">
  <div>
    <div class="title">Album to Video</div>
    <div class="subtitle">Turn cover art and audio files into clean MP4 exports.</div>
  </div>
  <div class="topActions">
    <button class="secondary" id="btnNewAlbum">New</button>
  </div>
</div>

<div class="grid">
  <div class="card">
    <h3>Tracks</h3>

    <div class="row first">
      <button id="btnAddTracks">Add Audio Files</button>
      <button class="danger" id="btnClearTracks">Clear</button>
    </div>

    <ul class="list" id="audioList"></ul>
  </div>

  <div class="card settingsCard">
    <h3>Settings</h3>

    <div class="row first">
      <label class="presetBlock" style="display:flex; flex-direction:column; gap:6px;">
        <span style="color:var(--muted); font-weight:850; font-size:12px;">Preset</span>
        <select id="presetSelect"></select>
        <span id="presetDescription"></span>
      </label>
    </div>

    <div class="inline">
      <label><input type="checkbox" id="createAlbumFolder" checked /> Create release folder</label>
      <div id="releaseFolderSection">
        <input type="text" id="albumName" placeholder="Release name" />
      </div>
    </div>

    <div class="row subSection">
      <button class="secondary" id="btnCover">Choose cover art</button>
      <button class="secondary" id="btnExport">Choose export folder</button>
    </div>

    <div class="coverPreviewRow subSection">
      <div class="coverPreview">
        <img id="coverImg" alt="Cover art" />
        <div class="coverPlaceholder" id="coverPlaceholder">No cover art</div>
      </div>
      <div class="coverMeta">
        <div class="coverMetaBox">
          <div class="coverMetaTitle">Cover art</div>
          <div class="coverMetaSub" id="coverPreviewText">No cover art</div>
        </div>
      </div>
    </div>

    <div class="kv">
      <div>Cover art:</div><div class="v" id="coverLabel">Not selected</div>
      <div>Export:</div><div class="v" id="exportLabel">Not selected</div>
      <div>Tracks:</div><div class="v" id="countLabel">0</div>
    </div>

    <div class="actionZone">

    <div class="row actionRow">
      <button id="renderBtn" class="primary">Export</button>
      <button id="cancelBtn" class="danger" disabled>Cancel</button>
      <button class="secondary isHidden" id="btnOpenFolder">Open output folder</button>
    </div>

    <div class="progressWrap" id="progressWrap">
      <div class="statusLine" id="statusLine">Ready</div>
      <div class="progressTitle" id="trackTitle">Track —</div>
      <div class="bar"><div class="fill total" id="totalFill"></div><div class="barText" id="overallPercent">0%</div></div>
      <div class="openRow hidden" id="logsRow">
        <button class="secondary" id="btnOpenLogs">Ver logs</button>
      </div>
    </div>

  </div>

  </div>
</div>
</div>
</div>
<div class="toastWrap" id="toastWrap"></div>

<script>
  function emitPerfMark(mark) {
    try {
      if (window.api && typeof window.api.perfMark === 'function') {
        window.api.perfMark(mark);
      }
    } catch {}
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => emitPerfMark('renderer.domContentLoaded'), { once: true });
  } else {
    emitPerfMark('renderer.domContentLoaded');
  }

  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      emitPerfMark('firstPaint');
    });
  });

  try {
    window.api?.dpiProbe?.({
      devicePixelRatio: window.devicePixelRatio,
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight,
      visualViewport: window.visualViewport ? {
        width: window.visualViewport.width,
        height: window.visualViewport.height,
        scale: window.visualViewport.scale,
      } : null,
    });
  } catch {}

  const audioList = document.getElementById('audioList');
  const coverLabel = document.getElementById('coverLabel');
  const exportLabel = document.getElementById('exportLabel');
  const countLabel = document.getElementById('countLabel');

  const presetSelect = document.getElementById('presetSelect');
  const presetDescription = document.getElementById('presetDescription');
  const createAlbumFolderEl = document.getElementById('createAlbumFolder');
  const albumNameEl = document.getElementById('albumName');
  const releaseFolderSection = document.getElementById('releaseFolderSection');

  const progressWrap = document.getElementById('progressWrap');
  const trackTitle = document.getElementById('trackTitle');
  const overallPercent = document.getElementById('overallPercent');
  const statusLine = document.getElementById('statusLine');
  const totalFill = document.getElementById('totalFill');

  const renderBtn = document.getElementById('renderBtn');
  const cancelBtn = document.getElementById('cancelBtn');

  const coverImg = document.getElementById('coverImg');
  const coverPlaceholder = document.getElementById('coverPlaceholder');
  const coverPreviewText = document.getElementById('coverPreviewText');

  const toastWrap = document.getElementById('toastWrap');
  const logsRow = document.getElementById('logsRow');

  const btnAddTracks = document.getElementById('btnAddTracks');
  const btnClearTracks = document.getElementById('btnClearTracks');
  const btnCover = document.getElementById('btnCover');
  const btnExport = document.getElementById('btnExport');
  const btnNewAlbum = document.getElementById('btnNewAlbum');
  const btnOpenFolder = document.getElementById('btnOpenFolder');
  const btnOpenLogs = document.getElementById('btnOpenLogs');
  const coverPreview = document.querySelector('.coverPreview');

  let tracks = []; // { path, displayName, outputBase, originalBase, trackNo, hasTrackNo, durationSec }
  let trackPathSet = new Set();
  let nextTrackOrder = 1;

  let imageFile = null;
  let exportFolder = null;

  let isRendering = false;
  let isValidating = false;
  let renderQueue = [];

  let lastFinalExportFolder = null;
  let lastLogFolder = null;
  let presetCatalog = [];
  let defaultPresetKey = 'album_ep';
  let statusResetTimer = null;
  let progressDisplay = 0;
  let progressTarget = 0;
  let progressRafId = null;
  let progressLastFrameTs = 0;
  let lastVisualProgress = 0;
  let hasDeterminateSignal = false;
  let lastProgressSignal = 'none';
  let disposeProgress = null;
  let disposeStatus = null;

  const uiDisableList = [
    btnAddTracks,
    btnClearTracks,
    btnCover,
    btnExport,
    btnNewAlbum,
    presetSelect,
    createAlbumFolderEl,
  ];

  function setUiLocked(locked) {
    uiDisableList.forEach((el) => {
      if (!el) return;
      el.disabled = !!locked;
    });
    renderBtn.disabled = !!locked;
    document.body.classList.toggle('locked', !!locked);
    updateReleaseFolderState();
  }

  function clearStatusResetTimer() {
    if (!statusResetTimer) return;
    clearTimeout(statusResetTimer);
    statusResetTimer = null;
  }

  function setStatus(text, resetAfterMs = 0) {
    clearStatusResetTimer();
    statusLine.textContent = text;
    if (resetAfterMs > 0) {
      statusResetTimer = setTimeout(() => {
        if (!isRendering) statusLine.textContent = 'Ready';
      }, resetAfterMs);
    }
  }

  function clamp01(value) {
    const n = Number(value);
    if (!Number.isFinite(n)) return 0;
    return Math.max(0, Math.min(1, n));
  }

  function applyDeterminateProgress(progress01) {
    const safe = clamp01(progress01);
    const pct = safe * 100;
    totalFill.style.width = `${pct.toFixed(1)}%`;
    overallPercent.textContent = `${Math.round(pct)}%`;
    lastVisualProgress = safe;
  }

  function readCurrentFillProgress() {
    const raw = String(totalFill.style.width || '').trim();
    const value = raw.endsWith('%') ? Number(raw.slice(0, -1)) : Number.NaN;
    if (!Number.isFinite(value)) return 0;
    return clamp01(value / 100);
  }

  function stopProgressRaf() {
    if (!progressRafId) return;
    cancelAnimationFrame(progressRafId);
    progressRafId = null;
  }

  function tickProgress(nowTs) {
    const now = Number(nowTs) || performance.now();
    const prev = progressLastFrameTs || now;
    const dt = Math.max(0, (now - prev) / 1000);
    progressLastFrameTs = now;

    const delta = Math.max(0, progressTarget - progressDisplay);
    const speed = Math.max(0.20, Math.min(2.0, 0.35 + (delta * 1.8)));
    progressDisplay = Math.min(progressDisplay + speed * dt, progressTarget);
    applyDeterminateProgress(progressDisplay);

    const stable = Math.abs(progressTarget - progressDisplay) < 0.0001;
    if (stable || !isRendering) {
      progressRafId = null;
      return;
    }
    progressRafId = requestAnimationFrame(tickProgress);
  }

  function startProgressRaf() {
    if (progressRafId) return;
    progressLastFrameTs = performance.now();
    progressRafId = requestAnimationFrame(tickProgress);
  }

  function completeProgressNow() {
    progressTarget = 1;
    progressDisplay = 1;
    hasDeterminateSignal = true;
    lastProgressSignal = 'both';
    applyDeterminateProgress(1);
    stopProgressRaf();
  }

  function resetOverallProgress() {
    stopProgressRaf();
    progressDisplay = 0;
    progressTarget = 0;
    progressLastFrameTs = 0;
    lastVisualProgress = 0;
    hasDeterminateSignal = false;
    lastProgressSignal = 'none';
    applyDeterminateProgress(0);
  }

  function updateReleaseFolderState() {
    const enabled = !!createAlbumFolderEl.checked;
    albumNameEl.disabled = isRendering || !enabled;
    releaseFolderSection.classList.toggle('dimmed', !enabled);
  }

  function sanitizeFolderName(name) {
    const cleaned = (name || '')
      .replace(/[\/\\:\*\?"<>\|]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
    return cleaned || 'Album';
  }

  function sanitizeFileBaseName(name) {
    const cleaned = (name || '')
      .replace(/[\/\\:\*\?"<>\|]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
    return cleaned || 'Untitled';
  }

  function pathBasename(p) {
    const normalized = String(p || '').replace(/\\/g, '/');
    const parts = normalized.split('/').filter(Boolean);
    return parts.length ? parts[parts.length - 1] : '';
  }

  function pathBasenameNoExt(p) {
    const base = pathBasename(p);
    const idx = base.lastIndexOf('.');
    return idx > 0 ? base.slice(0, idx) : base;
  }

  function pathJoin(base, child) {
    const lhs = String(base || '');
    const rhs = String(child || '');
    if (!lhs) return rhs;
    const sep = lhs.includes('\\') && !lhs.includes('/') ? '\\' : '/';
    const left = lhs.replace(/[\\/]+$/g, '');
    const right = rhs.replace(/^[\\/]+/g, '');
    return `${left}${sep}${right}`;
  }

  function pathDirname(p) {
    const raw = String(p || '').replace(/\\/g, '/');
    const noSlash = raw.replace(/\/+$/g, '');
    if (!noSlash) return '';
    const idx = noSlash.lastIndexOf('/');
    if (idx <= 0) return '';
    return noSlash.slice(0, idx);
  }

  function filePathToUrl(p) {
    const raw = String(p || '');
    const normalized = raw.replace(/\\/g, '/');
    if (/^[a-zA-Z]:\//.test(normalized)) return `file:///${encodeURI(normalized)}`;
    if (normalized.startsWith('/')) return `file://${encodeURI(normalized)}`;
    return `file://${encodeURI(normalized)}`;
  }

  function stripLeadingTrackNumber(s) {
    return (s || '').replace(/^\s*\d+\s*[\.\-\_\)]\s*/g, '').trim();
  }

  function pad2(n) {
    const x = parseInt(n, 10);
    if (!Number.isFinite(x) || x < 0) return null;
    return String(x).padStart(2, '0');
  }

  function updateCounts() { countLabel.textContent = String(tracks.length); }

  function showToast(message, type = 'info', ttlMs = 2400) {
    const el = document.createElement('div');
    el.className = `toast ${type}`;
    el.textContent = message;
    toastWrap.appendChild(el);

    requestAnimationFrame(() => el.classList.add('show'));
    setTimeout(() => {
      dismissToast(el);
    }, Math.max(800, ttlMs));
    return el;
  }

  function dismissToast(el) {
    if (!el || !el.isConnected) return;
    el.classList.remove('show');
    setTimeout(() => el.remove(), 200);
  }

  async function probeFilesWithLimit(files, limit = 4) {
    const results = new Map();
    let idx = 0;
    let active = 0;

    return new Promise((resolve) => {
      const next = () => {
        if (idx >= files.length && active === 0) {
          resolve(results);
          return;
        }

        while (active < limit && idx < files.length) {
          const f = files[idx++];
          active += 1;
          window.api.probeAudio(f)
            .then((info) => results.set(f, info))
            .catch(() => results.set(f, { ok: false, durationSec: 0 }))
            .finally(() => {
              active -= 1;
              next();
            });
        }
      };

      next();
    });
  }

  function showProgressUI() { progressWrap.style.display = 'block'; }
  function hideProgressUI({ preserveStatus = false } = {}) {
    resetOverallProgress();
    trackTitle.textContent = 'Track —';
    if (!preserveStatus) setStatus('Ready');
    btnOpenFolder.classList.add('isHidden');
    logsRow.classList.add('hidden');
  }

  function selectedPresetPolicy() {
    const selected = presetCatalog.find((p) => p.key === presetSelect.value);
    return selected?.policy || { ordering: 'input', prefixTrackNumber: false, maxTracks: null };
  }

  function describePreset(preset) {
    if (!preset) return '';
    if (preset.description) return preset.description;
    const map = {
      album_ep: 'Ideal for albums and EPs with multiple tracks in sequence.',
      single_track: 'Best for a single-song export with a quick setup.',
      long_form: 'Great for sets, podcasts, and long-form recordings.',
    };
    return map[preset.key] || '';
  }

  function updatePresetDescription() {
    const selected = presetCatalog.find((p) => p.key === presetSelect.value);
    presetDescription.textContent = describePreset(selected);
  }

  function shouldAutoSortByTrackNo() {
    if (!tracks.length) return false;
    const policy = selectedPresetPolicy();
    if (policy.ordering !== 'track_no_if_all_present') return false;
    return tracks.every((t) => t.hasTrackNo === true);
  }

  function sortTracksIfSafe() {
    if (shouldAutoSortByTrackNo()) {
      tracks.sort((a, b) => {
        if (a.trackNo !== b.trackNo) return a.trackNo - b.trackNo;
        return a.inputOrder - b.inputOrder;
      });
      return;
    }
    tracks.sort((a, b) => a.inputOrder - b.inputOrder);
  }

  function buildOutputBaseForTrack(track) {
    const base = sanitizeFileBaseName(track.outputBase || track.originalBase);
    if (!selectedPresetPolicy().prefixTrackNumber) return base;
    if (!track.hasTrackNo) return base;
    const p = pad2(track.trackNo);
    if (!p) return base;
    return sanitizeFileBaseName(`${p}. ${base}`);
  }

  let renderQueued = false;
  function scheduleRenderTrackList() {
    if (renderQueued) return;
    renderQueued = true;
    requestAnimationFrame(() => {
      renderQueued = false;
      renderTrackList();
    });
  }

  function renderTrackList() {
    audioList.innerHTML = '';

    tracks.forEach((t) => {
      const li = document.createElement('li');
      li.dataset.path = t.path;

      const text = document.createElement('div');
      text.className = 'trackText';

      const main = document.createElement('div');
      main.className = 'trackMain';
      const prefixDot = t.hasTrackNo ? `${pad2(t.trackNo)}. ` : '';
      main.textContent = `${prefixDot}${t.displayName || t.originalBase}`;

      const sub = document.createElement('div');
      sub.className = 'trackSub';
      const outPreviewBase = buildOutputBaseForTrack(t);
      sub.textContent = `${t.originalBase}  →  ${outPreviewBase}.mp4`;

      text.appendChild(main);
      text.appendChild(sub);

      const x = document.createElement('div');
      x.className = 'removeBtn';
      x.title = 'Remove';
      x.textContent = '✕';
      if (isRendering) x.classList.add('disabled');

      x.addEventListener('click', () => {
        tracks = tracks.filter(z => z.path !== t.path);
        trackPathSet.delete(t.path);
        sortTracksIfSafe();
        scheduleRenderTrackList();
      });

      li.appendChild(text);
      li.appendChild(x);

      audioList.appendChild(li);
    });

    updateCounts();
  }

  function clearTracksOnly() {
    tracks = [];
    trackPathSet = new Set();
    nextTrackOrder = 1;
    renderTrackList();
  }

  function clearCover() {
    imageFile = null;
    coverLabel.textContent = 'Not selected';
    coverImg.src = '';
    coverImg.style.display = 'none';
    coverPlaceholder.style.display = 'block';
    coverPreviewText.textContent = 'No cover art';
  }

  function clearExportFolder() {
    exportFolder = null;
    exportLabel.textContent = 'Not selected';
    lastFinalExportFolder = null;
  }

  function newAlbumReset() {
    if (isRendering) return;
    clearTracksOnly();
    clearCover();
    clearExportFolder();
    albumNameEl.value = '';
    presetSelect.value = defaultPresetKey;
    sortTracksIfSafe();
    scheduleRenderTrackList();
    hideProgressUI();
  }

  async function loadPresets() {
    let presets = [];
    try {
      presets = await window.api.listPresets();
    } catch {}

    if (!Array.isArray(presets) || !presets.length) {
      presets = [
        {
          key: 'album_ep',
          label: 'Album / EP — Recommended',
          description: 'Ideal for albums and EPs with multiple tracks in sequence.',
          policy: { ordering: 'track_no_if_all_present', prefixTrackNumber: true, maxTracks: null },
          recommended: true,
        },
        {
          key: 'single_track',
          label: 'Single / Track',
          description: 'Best for a single-song export with a quick setup.',
          policy: { ordering: 'input', prefixTrackNumber: false, maxTracks: 1 },
          recommended: false,
        },
        {
          key: 'long_form',
          label: 'Long-form Audio',
          description: 'Great for sets, podcasts, and long-form recordings.',
          policy: { ordering: 'input', prefixTrackNumber: false, maxTracks: null },
          recommended: false,
        },
      ];
    }

    presetCatalog = presets;
    presetSelect.innerHTML = '';
    presets.forEach((preset) => {
      const opt = document.createElement('option');
      opt.value = preset.key;
      opt.textContent = preset.label;
      presetSelect.appendChild(opt);
    });

    const recommended = presets.find((p) => p.recommended) || presets[0];
    defaultPresetKey = recommended.key;
    presetSelect.value = defaultPresetKey;
    updatePresetDescription();
    sortTracksIfSafe();
    scheduleRenderTrackList();
  }

  async function pickAudios() {
    if (isValidating) return;
    const files = await window.api.selectAudios();
    if (!files || !files.length) return;

    const newFiles = files.filter((f) => !trackPathSet.has(f));
    if (!newFiles.length) return;

    isValidating = true;
    btnAddTracks.disabled = true;
    btnNewAlbum.disabled = true;
    let validatingToast = null;
    const validatingToastTimer = setTimeout(() => {
      validatingToast = showToast('Validating audio', 'info', 999999);
    }, 180);

    try {
      newFiles.forEach((f) => trackPathSet.add(f));

      const probeResults = await probeFilesWithLimit(newFiles, 4);

      for (const f of newFiles) {
        const probe = probeResults.get(f);
        if (!probe?.ok) {
          const name = pathBasename(f);
          showToast(`Skipped unsupported file: ${name}`, 'warn', 3000);
          trackPathSet.delete(f);
          continue;
        }

        const originalBaseRaw = pathBasenameNoExt(f);
        const originalBase = stripLeadingTrackNumber(originalBaseRaw);

        tracks.push({
          path: f,
          displayName: originalBase + ' (reading tags)',
          outputBase: originalBase,
          originalBase,
          durationSec: Math.max(0, Number(probe?.durationSec) || 0),
          trackNo: null,
          hasTrackNo: false,
          inputOrder: nextTrackOrder++,
        });
      }

      scheduleRenderTrackList();

      for (const t of tracks) {
        if (!t.displayName.includes('(reading tags)')) continue;

        try {
          const info = await window.api.readMetadata(t.path);
          const artist = (info.artist || '').trim();
          const title = (info.title || '').trim();
          const album = (info.album || '').trim();

          const tn = info.trackNo;
          const trackNo = Number.isFinite(Number(tn)) ? Number(tn) : null;
          const hasTrackNo = Number.isFinite(trackNo) && trackNo > 0;

          let outputBase = '';
          if (artist && title) outputBase = `${artist} - ${title}`;
          else if (title) outputBase = title;
          else outputBase = t.originalBase;

          t.outputBase = sanitizeFileBaseName(stripLeadingTrackNumber(outputBase));
          t.displayName = t.outputBase;
          t.trackNo = hasTrackNo ? trackNo : null;
          t.hasTrackNo = hasTrackNo;

          if (!albumNameEl.value.trim() && album) albumNameEl.value = album;
        } catch {
          t.displayName = sanitizeFileBaseName(t.originalBase);
          t.outputBase = sanitizeFileBaseName(t.originalBase);
        }

        sortTracksIfSafe();
        scheduleRenderTrackList();
      }
    } finally {
      clearTimeout(validatingToastTimer);
      dismissToast(validatingToast);
      isValidating = false;
      btnAddTracks.disabled = false;
      btnNewAlbum.disabled = false;
    }
  }

  async function pickImage() {
    const file = await window.api.selectImage();
    if (!file) return;

    imageFile = file;
    const coverName = pathBasename(file);
    coverLabel.textContent = coverName;
    coverPreviewText.textContent = coverName;

    coverImg.src = filePathToUrl(file);
    coverImg.style.display = 'block';
    coverPlaceholder.style.display = 'none';
  }

  async function chooseFolder() {
    const folder = await window.api.selectFolder();
    if (!folder) return;
    exportFolder = folder;
    exportLabel.textContent = folder;
  }

  async function openOutputFolder() {
    if (!lastFinalExportFolder) return;
    await window.api.openFolder(lastFinalExportFolder);
  }

  async function openLogsFolder() {
    if (!lastLogFolder) return;
    await window.api.openFolder(lastLogFolder);
  }

  function humanizeErrorMessage(raw) {
    const msg = String(raw || '').trim();
    if (!msg) return 'Export failed.';
    const firstLine = msg.split(/\r?\n/).map((x) => x.trim()).find(Boolean) || '';
    if (/cancel/i.test(firstLine)) return 'Export cancelled.';
    if (/invoke|ipc|remote method/i.test(firstLine)) return 'The app could not complete this action.';
    return firstLine.replace(/^Error:\s*/i, '');
  }

  function uiLog(event, payload = {}, level = 'info') {
    const data = (payload && typeof payload === 'object' && !Array.isArray(payload)) ? payload : {};
    const entry = { event, level, ...data };
    const fn = level === 'error' ? console.error : (level === 'warn' ? console.warn : console.log);
    fn('[ui]', entry);
    try {
      window.api?.logUiEvent?.(entry);
    } catch {}
  }

  function buildReadyState() {
    return {
      hasTracks: tracks.length > 0,
      hasCover: Boolean(imageFile),
      hasExportFolder: Boolean(exportFolder),
      presetKey: presetSelect.value,
      createAlbumFolder: Boolean(createAlbumFolderEl.checked),
      isRendering,
      renderBtnDisabled: Boolean(renderBtn.disabled),
    };
  }

  function summarizeRenderPayload(payload) {
    return {
      trackCount: Array.isArray(payload?.tracks) ? payload.tracks.length : 0,
      hasCover: Boolean(payload?.imagePath),
      hasExportFolder: Boolean(payload?.exportFolder),
      presetKey: payload?.presetKey || '',
      createAlbumFolder: Boolean(payload?.createAlbumFolder),
      trackPreview: Array.isArray(payload?.tracks)
        ? payload.tracks.slice(0, 3).map((t) => pathBasename(t.audioPath || ''))
        : [],
    };
  }

  async function cancelRender() {
    if (!isRendering) return;
    await window.api.cancelRender();
  }

  function updateProgressFromEngine(payload) {
    if (!isRendering) return;
    const data = (payload && typeof payload === 'object') ? payload : {};
    const phase = String(data.phase || '').toUpperCase();
    const signalRaw = String(data.progressSignal || '').toLowerCase();
    const progressSignal = ['time', 'size', 'both'].includes(signalRaw) ? signalRaw : 'none';
    lastProgressSignal = progressSignal;
    const safeTrackCount = Math.max(1, Number(data.trackCount) || renderQueue.length || 1);
    const safeTrackIndex = Math.max(0, Math.min(safeTrackCount - 1, Number(data.trackIndex) || 0));
    const name = renderQueue?.[safeTrackIndex]?.displayName || renderQueue?.[safeTrackIndex]?.originalBase || '—';
    trackTitle.textContent = `Track ${safeTrackIndex + 1}/${safeTrackCount}: ${name}`;

    if (phase === 'PREPARING') setStatus('Preparing...');
    else if (phase === 'ENCODING' || phase === 'RENDERING') setStatus('Rendering...');
    else if (phase === 'FINALIZING') setStatus('Finalizing...');

    const raw = Number(data.rawProgress);
    const hasValidRaw = Number.isFinite(raw) && raw >= 0 && raw <= 1;
    if (!hasDeterminateSignal) {
      const visualFloor = Math.min(0.15, Math.max(lastVisualProgress, readCurrentFillProgress()));
      progressDisplay = Math.max(progressDisplay, visualFloor);
      hasDeterminateSignal = true;
      applyDeterminateProgress(progressDisplay);
    }
    let target = hasValidRaw ? raw : progressTarget;
    if (!Number.isFinite(target)) target = progressTarget;
    target = Math.min(target, 0.99);
    progressTarget = Math.max(progressTarget, target, progressDisplay);
    if (phase === 'PREPARING') setStatus('Starting...');
    startProgressRaf();
  }

  function ensureRenderListeners() {
    if (disposeProgress) disposeProgress();
    if (disposeStatus) disposeStatus();

    disposeProgress = window.api.onRenderProgress((payload) => updateProgressFromEngine(payload));

    disposeStatus = window.api.onRenderStatus(({ phase }) => {
      const normalized = String(phase || '').toLowerCase();
      if (!isRendering && normalized !== 'success') return;
      if (normalized === 'planning') {
        setStatus('Planning...');
      } else if (normalized === 'rendering') {
        setStatus('Rendering...');
        progressDisplay = 0;
        progressTarget = 0;
        applyDeterminateProgress(0);
      } else if (normalized === 'finalizing') {
        setStatus('Finalizing...');
        progressTarget = Math.max(progressTarget, 0.99, progressDisplay);
        startProgressRaf();
      } else if (normalized === 'success') {
        completeProgressNow();
        setStatus('Done');
      }
    });
  }

  window.addEventListener('beforeunload', () => {
    if (disposeProgress) disposeProgress();
    if (disposeStatus) disposeStatus();
  });

  async function renderAll() {
    const readyState = buildReadyState();
    uiLog('ui.export_click', readyState);
    if (isRendering) return;

    if (typeof window.api?.renderAlbum !== 'function') {
      const msg = 'Export failed — app API unavailable.';
      uiLog('ui.export_failed', { reason: 'render_api_missing', ...readyState, message: msg }, 'error');
      setStatus(msg, 2400);
      showToast(msg, 'warn', 3200);
      return;
    }

    if (!tracks.length) {
      const msg = 'Add audio files.';
      uiLog('ui.export_failed', { reason: 'missing_tracks', ...readyState, message: msg }, 'warn');
      setStatus(msg, 1800);
      showToast(msg, 'warn');
      return;
    }
    if (!imageFile) {
      const msg = 'Choose cover art.';
      uiLog('ui.export_failed', { reason: 'missing_cover', ...readyState, message: msg }, 'warn');
      setStatus(msg, 1800);
      showToast(msg, 'warn');
      return;
    }
    if (!exportFolder) {
      const msg = 'Choose export folder.';
      uiLog('ui.export_failed', { reason: 'missing_export_folder', ...readyState, message: msg }, 'warn');
      setStatus(msg, 1800);
      showToast(msg, 'warn');
      return;
    }

    const presetKey = presetSelect.value;
    const presetPolicy = selectedPresetPolicy();
    if (Number.isInteger(presetPolicy.maxTracks) && tracks.length > presetPolicy.maxTracks) {
      const msg = `Selected preset allows up to ${presetPolicy.maxTracks} track(s).`;
      uiLog('ui.export_failed', { reason: 'preset_max_tracks', ...readyState, message: msg }, 'warn');
      setStatus(msg, 3000);
      showToast(msg, 'warn', 3500);
      return;
    }

    const toRender = [...tracks];
    renderQueue = toRender;
    isRendering = true;
    setUiLocked(true);
    renderBtn.textContent = 'Exporting';
    cancelBtn.disabled = false;

    showProgressUI();
    resetOverallProgress();
    trackTitle.textContent = `Track 1/${Math.max(1, toRender.length)}: —`;
    btnOpenFolder.classList.add('isHidden');
    logsRow.classList.add('hidden');
    lastLogFolder = null;
    setStatus('Planning...');

    try {
      let finalExportFolder = exportFolder;
      if (createAlbumFolderEl.checked) {
        const safeAlbum = sanitizeFolderName(albumNameEl.value);
        finalExportFolder = await window.api.ensureDir({ albumFolderName: safeAlbum });
      }
      lastFinalExportFolder = finalExportFolder;

      const payload = {
        tracks: toRender.map((t) => ({
          audioPath: t.path,
          outputBase: sanitizeFileBaseName(t.outputBase || t.originalBase),
          trackNo: t.trackNo,
          hasTrackNo: t.hasTrackNo,
        })),
        imagePath: imageFile,
        exportFolder: finalExportFolder,
        presetKey,
        timeoutPerTrackMs: 30 * 60 * 1000,
        createAlbumFolder: !!createAlbumFolderEl.checked,
      };
      uiLog('ui.export_invoke', summarizeRenderPayload(payload));

      const res = await window.api.renderAlbum(payload);
      if (!res?.ok) {
        if (res?.error?.code === 'CANCELLED') {
          uiLog('ui.export_failed', { reason: 'cancelled', code: 'CANCELLED' }, 'warn');
          hideProgressUI({ preserveStatus: true });
          setStatus('Cancelled', 1200);
          showToast('Export cancelled.', 'warn');
        } else {
          const msg = humanizeErrorMessage(res?.error?.message || 'Unknown error');
          uiLog('ui.export_failed', {
            reason: 'render_album_not_ok',
            code: res?.error?.code || 'UNKNOWN',
            message: msg,
          }, 'error');
          hideProgressUI({ preserveStatus: true });
          setStatus('Export failed — check Logs');
          const reportFolder = pathDirname(res?.reportPath || '');
          if (reportFolder) {
            lastLogFolder = reportFolder;
            logsRow.classList.remove('hidden');
          }
          showToast(msg, 'warn', 5000);
        }
        return;
      }

      setStatus('Done');
      if (res?.debugLogPath) {
        const debugFolder = pathDirname(res.debugLogPath);
        if (debugFolder) lastLogFolder = debugFolder;
      }
      btnOpenFolder.classList.remove('isHidden');
    } catch (err) {
      const msg = humanizeErrorMessage(err?.message || err || 'Unknown error');
      uiLog('ui.export_failed', {
        reason: 'invoke_exception',
        message: msg,
        stack: String(err?.stack || ''),
      }, 'error');
      hideProgressUI({ preserveStatus: true });
      setStatus('Export failed — check Logs');
      showToast(msg, 'warn', 5000);
    } finally {
      isRendering = false;
      setUiLocked(false);
      renderBtn.textContent = 'Export';
      cancelBtn.disabled = true;
    }
  }

  btnAddTracks.addEventListener('click', pickAudios);
  btnClearTracks.addEventListener('click', clearTracksOnly);
  btnCover.addEventListener('click', pickImage);
  coverPreview.addEventListener('click', () => {
    if (!imageFile) pickImage();
  });
  btnExport.addEventListener('click', chooseFolder);
  btnNewAlbum.addEventListener('click', newAlbumReset);
  btnOpenFolder.addEventListener('click', openOutputFolder);
  btnOpenLogs.addEventListener('click', openLogsFolder);
  renderBtn.addEventListener('click', renderAll);
  cancelBtn.addEventListener('click', cancelRender);
  createAlbumFolderEl.addEventListener('change', updateReleaseFolderState);
  presetSelect.addEventListener('change', () => {
    updatePresetDescription();
    sortTracksIfSafe();
    scheduleRenderTrackList();
  });

  renderTrackList();
  clearCover();
  updateReleaseFolderState();
  hideProgressUI();
  ensureRenderListeners();
  loadPresets();
</script>

</body>
</html>
