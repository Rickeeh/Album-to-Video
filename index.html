<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' data: blob: file:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; connect-src 'self'; media-src 'self' file: blob:; object-src 'none'; base-uri 'self'; frame-ancestors 'none';" />
<title>fRender – Album to Video</title>
<style>
/*
  Window: 1100 × 760 px — fixed, no resize.
  φ = 1.618

  Key proportions:
  ┌ Right panel width   = 1100 / (1 + φ) = 1100 / 2.618 ≈ 420px  → left = 680px
  ├ Cover thumb height  = 420 / φ² = 420 / 2.618 ≈ 160px  → width = 160px (square)
  ├ Folder row height   = 160 / φ  ≈ 99px
  └ Titlebar height     = 44px (standard Electron macOS)

  Content height = 760 − 44 = 716px
  Right panel vertical budget (716px):
    Preset section   ≈ 140px
    Cover+folder     = 160 + 1 + 99 = 260px
    Summary          ≈ 96px   (716 − 140 − 260 − 220export = 96)
    Export section   ≈ 220px
    Total            = 716px ✓
*/

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg:          #080b10;
  --bg-panel:    #0c1018;
  --bg-surf:     #111826;
  --bg-surf2:    #161e2d;
  --bg-hover:    #192033;
  --bg-input:    #0e1520;

  --line:        rgba(255,255,255,0.068);
  --line-md:     rgba(255,255,255,0.11);
  --line-lg:     rgba(255,255,255,0.18);

  --t1: #e0e8f5;
  --t2: #7c8da8;
  --t3: #475060;
  --t4: #2a3448;

  --accent:   #3d86f5;
  --accent-d: rgba(61,134,245,0.10);
  --green:    #2cc886;
  --green-d:  rgba(44,200,134,0.10);
  --danger:   #e05050;
  --danger-d: rgba(224,80,80,0.12);

  --r1: 4px;  --r2: 6px;  --r3: 9px;  --r4: 13px;

  --f:  -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI Variable", "Segoe UI", sans-serif;
  --fm: "SF Mono", "Menlo", "Cascadia Code", "Consolas", monospace;

  --content-h: calc(100vh - 44px);
  --preset-h: calc(var(--content-h) * 0.19553);   /* 140 / 716 */
  --cover-h: calc(var(--content-h) * 0.22346);    /* 160 / 716 */
  --folder-h: calc(var(--content-h) * 0.13827);   /* 99 / 716 */
  --summary-h: calc(var(--content-h) * 0.13408);  /* 96 / 716 */
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  font-family: var(--f);
  font-size: 13px;
  background: var(--bg);
  color: var(--t1);
  -webkit-font-smoothing: antialiased;
  user-select: none;
}

button,
select,
input {
  font-family: inherit;
}

.app { display: flex; flex-direction: column; width: 100%; height: 100%; }

.tb {
  height: 44px;
  flex-shrink: 0;
  background: var(--bg-panel);
  border-bottom: 1px solid var(--line);
  display: flex;
  align-items: center;
  padding: 0 16px 0 80px;
  gap: 10px;
  -webkit-app-region: drag;
}
.tb-mark {
  width: 22px;
  height: 22px;
  background: var(--bg-surf2);
  border: 1px solid var(--line-md);
  border-radius: 5px;
  display: grid;
  place-items: center;
  font-family: var(--fm);
  font-size: 9px;
  font-weight: 700;
  color: #5a9bf7;
  flex-shrink: 0;
}
.tb-name { font-size: 12px; font-weight: 600; color: var(--t1); }
.tb-sep  { font-size: 11px; color: var(--t4); }
.tb-sub  { font-size: 11px; color: var(--t3); }
.tb-desc { font-size: 10px; color: var(--t4); margin-left: 4px; }
.tb-gap  { flex: 1; }
.tb-btn {
  -webkit-app-region: no-drag;
  height: 28px;
  padding: 0 12px;
  background: var(--bg-surf);
  border: 1px solid var(--line-md);
  border-radius: var(--r2);
  font-size: 11.5px;
  font-weight: 500;
  color: var(--t2);
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 5px;
  transition: background .12s, color .12s, border-color .12s;
}
.tb-btn:hover { background: var(--bg-hover); color: var(--t1); border-color: var(--line-lg); }

.main {
  flex: 1;
  display: flex;
  overflow: hidden;
  min-height: 0;
}

.left {
  flex: 1;
  display: flex;
  flex-direction: column;
  border-right: 1px solid var(--line);
  background: var(--bg-panel);
  overflow: hidden;
  min-height: 0;
}

.right {
  width: 420px;
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  background: var(--bg-panel);
  overflow: hidden;
}

.sec-hd {
  height: 40px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  padding: 0 20px;
  gap: 10px;
  border-bottom: 1px solid var(--line);
}
.sec-lbl {
  font-size: 10px;
  font-weight: 700;
  letter-spacing: .1em;
  text-transform: uppercase;
  color: var(--t3);
  flex: 1;
}

.btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 500;
  height: 28px;
  padding: 0 12px;
  border-radius: var(--r2);
  border: 1px solid transparent;
  cursor: pointer;
  transition: opacity .12s, background .12s, border-color .12s, transform .08s;
  white-space: nowrap;
}
.btn:active { transform: scale(.97); }
.btn-a { background: var(--accent); color: #fff; }
.btn-a:hover { opacity: .86; }
.btn-a:disabled { opacity: .3; cursor: not-allowed; transform: none; }
.btn-g { background: transparent; border-color: var(--line-md); color: var(--t2); }
.btn-g:hover { background: var(--bg-hover); color: var(--t1); border-color: var(--line-lg); }
.btn-d { background: var(--danger-d); border-color: rgba(224,80,80,.2); color: var(--danger); }
.btn-d:hover { background: rgba(224,80,80,.18); border-color: rgba(224,80,80,.32); }
.btn-d:disabled { opacity: .3; cursor: not-allowed; transform: none; }
.btn-sm { height: 26px; font-size: 11.5px; padding: 0 10px; }

.badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 18px;
  height: 16px;
  padding: 0 5px;
  border-radius: 8px;
  font-size: 10px;
  font-weight: 600;
  font-family: var(--fm);
  background: var(--bg-surf2);
  color: var(--t3);
  border: 1px solid var(--line);
}
.badge.on { background: var(--accent-d); color: var(--accent); border-color: rgba(61,134,245,.22); }

.tracks-body {
  flex: 1;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
}
.tracks-body::-webkit-scrollbar { width: 3px; }
.tracks-body::-webkit-scrollbar-thumb { background: var(--line-md); border-radius: 2px; }

#track-list { min-height: 100%; }

.t-empty {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
  opacity: .4;
}
.t-empty-icon {
  width: 36px;
  height: 36px;
  border: 1.5px dashed var(--line-lg);
  border-radius: var(--r3);
  display: grid;
  place-items: center;
  color: var(--t3);
}
.t-empty-txt { font-size: 11.5px; color: var(--t3); text-align: center; line-height: 1.6; }

.t-row {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 9px 20px;
  border-bottom: 1px solid var(--line);
  transition: background .1s;
}
.t-row:hover { background: var(--bg-hover); }
.t-no {
  font-family: var(--fm);
  font-size: 10px;
  color: var(--t4);
  width: 18px;
  text-align: right;
  flex-shrink: 0;
}
.t-info { flex: 1; min-width: 0; }
.t-name {
  font-size: 12.5px;
  font-weight: 500;
  color: var(--t1);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.t-meta {
  font-size: 10px;
  color: var(--t3);
  margin-top: 2px;
  display: flex;
  align-items: center;
  gap: 6px;
  min-width: 0;
}
.t-meta span {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.t-sep { width: 2px; height: 2px; border-radius: 50%; background: var(--t4); flex-shrink: 0; }
.t-st {
  flex-shrink: 0;
  width: 14px;
  height: 14px;
  display: grid;
  place-items: center;
  color: var(--t4);
  font-size: 10px;
}
.t-rm {
  width: 18px;
  height: 18px;
  border-radius: 3px;
  border: none;
  background: transparent;
  color: var(--t3);
  cursor: pointer;
  display: grid;
  place-items: center;
  opacity: 0;
  flex-shrink: 0;
  transition: opacity .12s, background .12s, color .12s;
}
.t-row:hover .t-rm { opacity: 1; }
.t-rm:hover { background: var(--danger-d); color: var(--danger); }
.t-rm:disabled,
.t-row:hover .t-rm:disabled {
  opacity: .35;
  cursor: not-allowed;
  color: var(--t4);
  background: transparent;
}

.r-sec { padding: 14px 20px; border-bottom: 1px solid var(--line); flex-shrink: 0; height: var(--preset-h); }

.sec-mini {
  font-size: 10px;
  font-weight: 700;
  letter-spacing: .1em;
  text-transform: uppercase;
  color: var(--t3);
  margin-bottom: 10px;
}

.sel-w { position: relative; margin-bottom: 8px; }
.sel-w select {
  width: 100%;
  appearance: none;
  background: var(--bg-input);
  border: 1px solid var(--line-md);
  border-radius: var(--r2);
  color: var(--t1);
  font-size: 12px;
  font-weight: 500;
  padding: 0 26px 0 10px;
  height: 28px;
  cursor: pointer;
}
.sel-w select:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-d); }
.sel-w::after {
  content: '';
  position: absolute;
  right: 9px;
  top: 50%;
  transform: translateY(-50%);
  width: 7px;
  height: 4px;
  clip-path: polygon(0 0, 100% 0, 50% 100%);
  background: var(--t3);
  pointer-events: none;
}
.sel-desc {
  font-size: 10.5px;
  color: var(--t3);
  line-height: 1.5;
  min-height: 30px;
  margin-bottom: 10px;
}

.chk-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.chk-row input[type=checkbox] { width: 13px; height: 13px; accent-color: var(--accent); cursor: pointer; flex-shrink: 0; }
.chk-row label { font-size: 11.5px; font-weight: 500; color: var(--t2); cursor: pointer; flex: 1; }

#release-folder-section.dimmed {
  opacity: .55;
}
#release-folder-section.dimmed .txt-in {
  pointer-events: none;
}

.txt-in {
  width: 100%;
  background: var(--bg-input);
  border: 1px solid var(--line-md);
  border-radius: var(--r2);
  color: var(--t1);
  font-size: 12px;
  padding: 0 10px;
  height: 28px;
}
.txt-in::placeholder { color: var(--t3); }
.txt-in:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-d); }

.cover-block { flex-shrink: 0; border-bottom: 1px solid var(--line); }
.cover-row { display: flex; height: var(--cover-h); }

.cover-thumb {
  width: var(--cover-h);
  flex-shrink: 0;
  background: var(--bg-surf2);
  border-right: 1px solid var(--line);
  position: relative;
  overflow: hidden;
  display: grid;
  place-items: center;
}
.cover-thumb img {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: none;
}
.cover-ph {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 7px;
  opacity: .28;
}
.cover-ph span { font-size: 9px; color: var(--t3); letter-spacing: .04em; }

.cover-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding: 0 16px;
  gap: 4px;
  min-width: 0;
}
.cover-fname {
  font-size: 12px;
  font-weight: 600;
  color: var(--t1);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.cover-fname.empty { color: var(--t3); font-weight: 400; }
.cover-fdims { font-size: 10px; font-family: var(--fm); color: var(--t3); margin-bottom: 10px; }

.cover-art-btn {
  align-self: flex-start;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-size: 11.5px;
  font-weight: 500;
  height: 26px;
  padding: 0 11px;
  border-radius: var(--r2);
  border: 1px solid var(--line-md);
  background: transparent;
  color: var(--t2);
  cursor: pointer;
  transition: background .12s, color .12s, border-color .12s;
}
.cover-art-btn:hover { background: var(--bg-hover); color: var(--t1); border-color: var(--line-lg); }

.folder-row { display: flex; height: var(--folder-h); border-top: 1px solid var(--line); }

.folder-thumb-col {
  width: var(--cover-h);
  flex-shrink: 0;
  border-right: 1px solid var(--line);
  display: grid;
  place-items: center;
  color: var(--t4);
}

.folder-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding: 0 16px;
  gap: 6px;
  min-width: 0;
}
.folder-label-txt {
  font-size: 10px;
  font-weight: 700;
  letter-spacing: .1em;
  text-transform: uppercase;
  color: var(--t3);
}
.folder-path-txt {
  font-size: 11.5px;
  color: var(--t2);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.folder-path-txt.empty { color: var(--t3); }
.folder-path-txt.ok    { color: var(--green); }

.folder-browse-btn {
  align-self: flex-start;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-size: 11.5px;
  font-weight: 500;
  height: 26px;
  padding: 0 11px;
  border-radius: var(--r2);
  border: 1px solid var(--line-md);
  background: transparent;
  color: var(--t2);
  cursor: pointer;
  transition: background .12s, color .12s, border-color .12s;
}
.folder-browse-btn:hover { background: var(--bg-hover); color: var(--t1); border-color: var(--line-lg); }

.r-summary { padding: 12px 20px; border-bottom: 1px solid var(--line); flex-shrink: 0; height: var(--summary-h); }
.sum-grid { display: grid; grid-template-columns: auto 1fr; gap: 0; }
.sk { padding: 3.5px 10px 3.5px 0; font-size: 11px; color: var(--t3); }
.sv {
  padding: 3.5px 0;
  font-size: 11px;
  font-weight: 500;
  color: var(--t2);
  text-align: right;
  font-family: var(--fm);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.sv.dim { color: var(--t3); font-family: var(--f); font-weight: 400; }
.sv.ok  { color: var(--green); }

.export-sec {
  flex: 1;
  min-height: 0;
  border-top: 1px solid var(--line);
  padding: 20px 20px 18px;
  display: flex;
  flex-direction: column;
  gap: 14px;
}
.export-btns { display: flex; gap: 8px; }

.btn-export {
  flex: 1;
  justify-content: center;
  height: 36px;
  font-size: 13px;
  font-weight: 600;
  border-radius: var(--r3);
}
.btn-cancel {
  flex: 1;
  justify-content: center;
  height: 36px;
  font-size: 13px;
  font-weight: 600;
  border-radius: var(--r3);
  max-width: 96px;
}

.prog-wrap { display: flex; flex-direction: column; gap: 8px; }
.prog-meta { display: flex; align-items: baseline; justify-content: space-between; }
.prog-lbl {
  font-size: 10px;
  font-weight: 700;
  letter-spacing: .09em;
  text-transform: uppercase;
  color: var(--t3);
}
.prog-pct {
  font-family: var(--fm);
  font-size: 15px;
  font-weight: 700;
  color: var(--t2);
  letter-spacing: -.02em;
}
.prog-track {
  width: 100%;
  height: 24px;
  background: var(--bg-surf2);
  border-radius: var(--r2);
  border: 1px solid var(--line);
  overflow: hidden;
  position: relative;
}
.prog-fill {
  height: 100%;
  border-radius: var(--r2);
  background: var(--accent);
  transition: width .35s ease;
  position: relative;
}
.prog-fill::after {
  content: '';
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  width: 80px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.15));
  animation: sh 1.6s ease-in-out infinite;
}
@keyframes sh { 0%,100%{opacity:0} 50%{opacity:1} }
.prog-fill.done { background: var(--green); }
.prog-fill.done::after, .prog-fill.idle::after { display: none; }
.prog-fill.idle { transition: none; }

.st-line { display: flex; align-items: center; gap: 6px; min-height: 14px; }
.st-dot  { width: 5px; height: 5px; border-radius: 50%; background: var(--t4); flex-shrink: 0; }
.st-dot.active { background: var(--accent); box-shadow: 0 0 5px var(--accent); animation: bl 1.2s ease-in-out infinite; }
.st-dot.done   { background: var(--green); box-shadow: none; animation: none; }
@keyframes bl  { 0%,100%{opacity:1} 50%{opacity:.3} }
.st-txt { font-size: 10.5px; color: var(--t3); }

.open-actions {
  display: flex;
  gap: 8px;
}

.is-hidden { display: none !important; }

#track-title {
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  border: 0;
  overflow: hidden;
  clip: rect(0 0 0 0);
}

.toast-wrap {
  position: fixed;
  right: 18px;
  bottom: 18px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 30;
  pointer-events: none;
}
.toast {
  background: rgba(15,21,35,0.94);
  border: 1px solid var(--line-md);
  color: var(--t1);
  padding: 10px 12px;
  border-radius: 10px;
  font-size: 12px;
  font-weight: 700;
  letter-spacing: .2px;
  box-shadow: 0 8px 20px rgba(0,0,0,.35);
  opacity: 0;
  transform: translateY(6px);
  transition: opacity .18s ease, transform .18s ease;
}
.toast.show { opacity: 1; transform: translateY(0); }
.toast.warn { border-color: rgba(255,107,107,.35); color: var(--danger); }
.toast.info { border-color: rgba(61,134,245,.45); color: #8fc6ff; }
</style>
</head>
<body>
<div class="app">
  <div class="tb">
    <div class="tb-mark">f</div>
    <span class="tb-name">fRender</span>
    <span class="tb-sep">—</span>
    <span class="tb-sub">Album to Video</span>
    <span class="tb-desc">· Convert audio to clean MP4 exports. One image. No surprises.</span>
    <div class="tb-gap"></div>
    <button class="tb-btn" id="btn-new" type="button">
      <svg width="10" height="10" viewBox="0 0 10 10" fill="none"><path d="M5 1v8M1 5h8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
      New
    </button>
  </div>

  <div class="main">
    <div class="left">
      <div class="sec-hd">
        <span class="sec-lbl">Tracks</span>
        <span class="badge" id="track-badge">0</span>
        <div style="display:flex;gap:6px;margin-left:8px;">
          <button class="btn btn-a btn-sm" id="btn-add" type="button">
            <svg width="9" height="9" viewBox="0 0 9 9" fill="none"><path d="M4.5 1v7M1 4.5h7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
            Add Files
          </button>
          <button class="btn btn-g btn-sm" id="btn-clear" type="button" disabled>Clear</button>
        </div>
      </div>
      <div class="tracks-body" id="tracks-body">
        <div class="t-empty" id="tracks-empty">
          <div class="t-empty-icon">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M8 2v12M2 8h12" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/></svg>
          </div>
          <p class="t-empty-txt">No tracks added.<br>Click Add Files to begin.</p>
        </div>
        <div id="track-list" aria-live="polite"></div>
      </div>
    </div>

    <div class="right">
      <div class="r-sec">
        <div class="sec-mini">Preset</div>
        <div class="sel-w">
          <select id="select-preset" aria-label="Export preset"></select>
        </div>
        <p class="sel-desc" id="preset-desc"></p>
        <div class="chk-row">
          <input type="checkbox" id="chk-folder" checked />
          <label for="chk-folder">Create release folder</label>
        </div>
        <div id="release-folder-section">
          <input class="txt-in" type="text" placeholder="Release name" id="input-folder-name" />
        </div>
      </div>

      <div class="cover-block">
        <div class="cover-row">
          <div class="cover-thumb" id="cover-thumb">
            <img id="cover-img" alt="Cover art" />
            <div class="cover-ph" id="cover-ph">
              <svg width="22" height="22" viewBox="0 0 22 22" fill="none">
                <rect x="1.5" y="1.5" width="19" height="19" rx="3.5" stroke="currentColor" stroke-width="1.3"/>
                <circle cx="7.5" cy="7.5" r="2.2" fill="currentColor"/>
                <path d="M1.5 15.5l5-5.5 4 4 3.5-3.5L21 16" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
              <span>No image</span>
            </div>
          </div>
          <div class="cover-info">
            <div class="cover-fname empty" id="cover-fname">Not selected</div>
            <div class="cover-fdims" id="cover-fdims">JPG · PNG · WebP</div>
            <button class="cover-art-btn" id="btn-art" type="button">
              <svg width="10" height="10" viewBox="0 0 10 10" fill="none"><rect x=".5" y=".5" width="9" height="9" rx="1.5" stroke="currentColor" stroke-width=".9"/><circle cx="3.2" cy="3.2" r=".9" fill="currentColor" opacity=".7"/><path d="M.5 7L3 4.5l2 2L6.5 5 9.5 8" stroke="currentColor" stroke-width=".9" stroke-linecap="round" stroke-linejoin="round" opacity=".7"/></svg>
              <span id="art-btn-lbl">Choose cover art</span>
            </button>
          </div>
        </div>

        <div class="folder-row">
          <div class="folder-thumb-col">
            <svg width="20" height="18" viewBox="0 0 20 18" fill="none">
              <path d="M1 6h18M1 6v9.25A.75.75 0 001.75 16h16.5a.75.75 0 00.75-.75V7a.75.75 0 00-.75-.75H9.5L7.5 4H2A1 1 0 001 5v1z" stroke="currentColor" stroke-width="1.2" stroke-linejoin="round"/>
            </svg>
          </div>
          <div class="folder-info">
            <div class="folder-label-txt">Export folder</div>
            <div class="folder-path-txt empty" id="folder-path">Not selected</div>
            <button class="folder-browse-btn" id="btn-folder" type="button">
              <svg width="10" height="10" viewBox="0 0 10 10" fill="none"><path d="M1 3.5h8M1 3.5V7.5a.5.5 0 00.5.5h7a.5.5 0 00.5-.5V4a.5.5 0 00-.5-.5H4.5L3.5 2H1.5a.5.5 0 00-.5.5v1z" stroke="currentColor" stroke-width="1" stroke-linejoin="round"/></svg>
              Browse
            </button>
          </div>
        </div>
      </div>

      <div class="r-summary">
        <div class="sec-mini">Summary</div>
        <div class="sum-grid">
          <span class="sk">Cover art</span>  <span class="sv dim" id="info-cover">Not selected</span>
          <span class="sk">Export to</span>  <span class="sv dim" id="info-folder">Not selected</span>
          <span class="sk">Tracks</span>     <span class="sv" id="info-tracks">0</span>
          <span class="sk">Duration</span>   <span class="sv dim" id="info-duration">—</span>
        </div>
      </div>

      <div class="export-sec">
        <div class="export-btns">
          <button class="btn btn-a btn-export" id="btn-export" type="button" disabled>
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none"><path d="M6 1v8M3 7l3 3 3-3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M1 11h10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
            Export
          </button>
          <button class="btn btn-d btn-cancel" id="btn-cancel" type="button" disabled>Cancel</button>
        </div>

        <div class="prog-wrap" id="progress-wrap">
          <div class="prog-meta">
            <span class="prog-lbl" id="prog-label">Ready</span>
            <span class="prog-pct" id="prog-pct">0%</span>
          </div>
          <div class="prog-track">
            <div class="prog-fill idle" id="prog-fill" style="width:0%"></div>
          </div>
          <div class="st-line">
            <div class="st-dot" id="st-dot"></div>
            <span class="st-txt" id="st-txt">Add tracks and a cover image to begin.</span>
          </div>
          <div class="open-actions is-hidden" id="open-actions">
            <button class="btn btn-g btn-sm" id="btn-open-folder" type="button">Output folder</button>
            <button class="btn btn-g btn-sm is-hidden" id="btn-open-logs" type="button">View logs</button>
          </div>
          <span id="track-title">Track —</span>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="toast-wrap" id="toast-wrap"></div>

<script>
  function emitPerfMark(mark) {
    try {
      if (window.api && typeof window.api.perfMark === 'function') {
        window.api.perfMark(mark);
      }
    } catch {}
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => emitPerfMark('renderer.domContentLoaded'), { once: true });
  } else {
    emitPerfMark('renderer.domContentLoaded');
  }

  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      emitPerfMark('firstPaint');
    });
  });

  try {
    window.api?.dpiProbe?.({
      devicePixelRatio: window.devicePixelRatio,
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight,
      visualViewport: window.visualViewport ? {
        width: window.visualViewport.width,
        height: window.visualViewport.height,
        scale: window.visualViewport.scale,
      } : null,
    });
  } catch {}

  const tracksBody = document.getElementById('tracks-body');
  const tracksEmpty = document.getElementById('tracks-empty');
  const trackList = document.getElementById('track-list');
  const trackBadge = document.getElementById('track-badge');

  const coverLabel = document.getElementById('info-cover');
  const exportLabel = document.getElementById('info-folder');
  const countLabel = document.getElementById('info-tracks');
  const durationLabel = document.getElementById('info-duration');

  const presetSelect = document.getElementById('select-preset');
  const presetDescription = document.getElementById('preset-desc');
  const createAlbumFolderEl = document.getElementById('chk-folder');
  const albumNameEl = document.getElementById('input-folder-name');
  const releaseFolderSection = document.getElementById('release-folder-section');

  const progressWrap = document.getElementById('progress-wrap');
  const trackTitle = document.getElementById('track-title');
  const overallPercent = document.getElementById('prog-pct');
  const statusLine = document.getElementById('st-txt');
  const statusDot = document.getElementById('st-dot');
  const statusLabel = document.getElementById('prog-label');
  const totalFill = document.getElementById('prog-fill');

  const renderBtn = document.getElementById('btn-export');
  const cancelBtn = document.getElementById('btn-cancel');

  const coverImg = document.getElementById('cover-img');
  const coverPlaceholder = document.getElementById('cover-ph');
  const coverPreviewText = document.getElementById('cover-fname');
  const coverDimsLabel = document.getElementById('cover-fdims');
  const artBtnLabel = document.getElementById('art-btn-lbl');

  const toastWrap = document.getElementById('toast-wrap');
  const openActions = document.getElementById('open-actions');

  const btnAddTracks = document.getElementById('btn-add');
  const btnClearTracks = document.getElementById('btn-clear');
  const btnCover = document.getElementById('btn-art');
  const btnExport = document.getElementById('btn-folder');
  const btnNewAlbum = document.getElementById('btn-new');
  const btnOpenFolder = document.getElementById('btn-open-folder');
  const btnOpenLogs = document.getElementById('btn-open-logs');
  const coverPreview = document.getElementById('cover-thumb');
  const folderPathLabel = document.getElementById('folder-path');

  let tracks = [];
  let trackPathSet = new Set();
  let nextTrackOrder = 1;

  let imageFile = null;
  let exportFolder = null;

  let isRendering = false;
  let isValidating = false;
  let uiLocked = false;
  let audioDialogInFlight = false;
  let imageDialogInFlight = false;
  let folderDialogInFlight = false;
  let renderQueue = [];

  let lastFinalExportFolder = null;
  let lastLogFolder = null;
  let presetCatalog = [];
  let defaultPresetKey = 'album_ep';
  let statusResetTimer = null;
  let progressDisplay = 0;
  let progressTarget = 0;
  let progressRafId = null;
  let progressLastFrameTs = 0;
  let lastVisualProgress = 0;
  let hasDeterminateSignal = false;
  let lastProgressSignal = 'none';
  let disposeProgress = null;
  let disposeStatus = null;
  const PROGRESS_CAP_FINISHING = 0.995;

  const uiDisableList = [
    btnAddTracks,
    btnClearTracks,
    btnCover,
    btnExport,
    btnNewAlbum,
    presetSelect,
    createAlbumFolderEl,
  ];

  function setUiLocked(locked) {
    uiLocked = !!locked;
    uiDisableList.forEach((el) => {
      if (!el) return;
      el.disabled = !!locked;
    });
    document.body.classList.toggle('locked', !!locked);
    refreshActionState();
    updateReleaseFolderState();
  }

  function clearStatusResetTimer() {
    if (!statusResetTimer) return;
    clearTimeout(statusResetTimer);
    statusResetTimer = null;
  }

  function readyHintText() {
    const missing = [];
    if (!tracks.length) missing.push('tracks');
    if (!imageFile) missing.push('cover art');
    if (!exportFolder) missing.push('export folder');
    if (missing.length) return `Add ${missing.join(', ')} to begin.`;
    return 'Ready to export.';
  }

  function setStatusDot(mode) {
    const key = String(mode || '').toLowerCase();
    const activeSet = new Set(['planning', 'preparing', 'starting', 'rendering', 'finalizing', 'exporting', 'cancelling']);
    statusDot.classList.remove('active', 'done');
    if (key === 'done') {
      statusDot.classList.add('done');
      return;
    }
    if (activeSet.has(key)) {
      statusDot.classList.add('active');
    }
  }

  function setStatus(text, resetAfterMs = 0) {
    clearStatusResetTimer();
    const normalized = String(text || '').trim() || 'Ready';
    statusLabel.textContent = normalized;
    statusLine.textContent = normalized === 'Ready' ? readyHintText() : normalized;
    setStatusDot(normalized);
    if (resetAfterMs > 0) {
      statusResetTimer = setTimeout(() => {
        if (!isRendering) {
          statusLabel.textContent = 'Ready';
          statusLine.textContent = readyHintText();
          setStatusDot('ready');
        }
      }, resetAfterMs);
    }
  }

  function clamp01(value) {
    const n = Number(value);
    if (!Number.isFinite(n)) return 0;
    return Math.max(0, Math.min(1, n));
  }

  function applyDeterminateProgress(progress01) {
    const safe = clamp01(progress01);
    const pct = safe * 100;
    totalFill.style.width = `${pct.toFixed(1)}%`;
    overallPercent.textContent = `${Math.round(pct)}%`;
    lastVisualProgress = safe;
  }

  function readCurrentFillProgress() {
    const raw = String(totalFill.style.width || '').trim();
    const value = raw.endsWith('%') ? Number(raw.slice(0, -1)) : Number.NaN;
    if (!Number.isFinite(value)) return 0;
    return clamp01(value / 100);
  }

  function stopProgressRaf() {
    if (!progressRafId) return;
    cancelAnimationFrame(progressRafId);
    progressRafId = null;
  }

  function tickProgress(nowTs) {
    const now = Number(nowTs) || performance.now();
    const prev = progressLastFrameTs || now;
    const dt = Math.max(0, (now - prev) / 1000);
    progressLastFrameTs = now;

    const delta = Math.max(0, progressTarget - progressDisplay);
    const speed = Math.max(0.20, Math.min(2.0, 0.35 + (delta * 1.8)));
    progressDisplay = Math.min(progressDisplay + speed * dt, progressTarget);
    applyDeterminateProgress(progressDisplay);

    const stable = Math.abs(progressTarget - progressDisplay) < 0.0001;
    if (stable || !isRendering) {
      progressRafId = null;
      return;
    }
    progressRafId = requestAnimationFrame(tickProgress);
  }

  function startProgressRaf() {
    if (progressRafId) return;
    progressLastFrameTs = performance.now();
    progressRafId = requestAnimationFrame(tickProgress);
  }

  function completeProgressNow() {
    progressTarget = 1;
    progressDisplay = 1;
    hasDeterminateSignal = true;
    lastProgressSignal = 'both';
    applyDeterminateProgress(1);
    totalFill.classList.remove('idle');
    totalFill.classList.add('done');
    setStatusDot('done');
    stopProgressRaf();
  }

  function resetOverallProgress() {
    stopProgressRaf();
    progressDisplay = 0;
    progressTarget = 0;
    progressLastFrameTs = 0;
    lastVisualProgress = 0;
    hasDeterminateSignal = false;
    lastProgressSignal = 'none';
    totalFill.classList.remove('done');
    totalFill.classList.add('idle');
    applyDeterminateProgress(0);
  }

  function updateReleaseFolderState() {
    const enabled = !!createAlbumFolderEl.checked;
    albumNameEl.disabled = isRendering || !enabled;
    releaseFolderSection.classList.toggle('dimmed', !enabled);
  }

  function sanitizeFolderName(name) {
    const cleaned = (name || '')
      .replace(/[\/\\:\*\?"<>\|]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
    return cleaned || 'Album';
  }

  function sanitizeFileBaseName(name) {
    const cleaned = (name || '')
      .replace(/[\/\\:\*\?"<>\|]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
    return cleaned || 'Untitled';
  }

  function pathBasename(p) {
    const normalized = String(p || '').replace(/\\/g, '/');
    const parts = normalized.split('/').filter(Boolean);
    return parts.length ? parts[parts.length - 1] : '';
  }

  function pathBasenameNoExt(p) {
    const base = pathBasename(p);
    const idx = base.lastIndexOf('.');
    return idx > 0 ? base.slice(0, idx) : base;
  }

  function pathDirname(p) {
    const raw = String(p || '').replace(/\\/g, '/');
    const noSlash = raw.replace(/\/+$/g, '');
    if (!noSlash) return '';
    const idx = noSlash.lastIndexOf('/');
    if (idx <= 0) return '';
    return noSlash.slice(0, idx);
  }

  function filePathToUrl(p) {
    const raw = String(p || '');
    const normalized = raw.replace(/\\/g, '/');
    if (/^[a-zA-Z]:\//.test(normalized)) return `file:///${encodeURI(normalized)}`;
    if (normalized.startsWith('/')) return `file://${encodeURI(normalized)}`;
    return `file://${encodeURI(normalized)}`;
  }

  function stripLeadingTrackNumber(s) {
    return (s || '').replace(/^\s*\d+\s*[\.\-\_\)]\s*/g, '').trim();
  }

  function pad2(n) {
    const x = parseInt(n, 10);
    if (!Number.isFinite(x) || x < 0) return null;
    return String(x).padStart(2, '0');
  }

  function formatDuration(totalSec) {
    const sec = Math.max(0, Math.round(Number(totalSec) || 0));
    if (sec <= 0) return '—';
    const h = Math.floor(sec / 3600);
    const m = Math.floor((sec % 3600) / 60);
    const s = sec % 60;
    if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    return `${m}:${String(s).padStart(2, '0')}`;
  }

  function formatTrackDuration(totalSec) {
    const sec = Math.max(0, Math.round(Number(totalSec) || 0));
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${m}:${String(s).padStart(2, '0')}`;
  }

  function refreshActionState() {
    const ready = !uiLocked && !isRendering && !isValidating && tracks.length > 0 && Boolean(imageFile) && Boolean(exportFolder);
    renderBtn.disabled = !ready;
    btnClearTracks.disabled = uiLocked || isRendering || tracks.length === 0;

    countLabel.textContent = String(tracks.length);
    trackBadge.textContent = String(tracks.length);
    trackBadge.classList.toggle('on', tracks.length > 0);

    const durationSec = tracks.reduce((sum, t) => sum + Math.max(0, Number(t.durationSec) || 0), 0);
    durationLabel.textContent = formatDuration(durationSec);
    durationLabel.className = tracks.length > 0 ? 'sv' : 'sv dim';

    if (!isRendering && statusLabel.textContent === 'Ready') {
      statusLine.textContent = readyHintText();
      setStatusDot(ready ? 'done' : 'ready');
    }
  }

  function showToast(message, type = 'info', ttlMs = 2400) {
    const el = document.createElement('div');
    el.className = `toast ${type}`;
    el.textContent = message;
    toastWrap.appendChild(el);

    requestAnimationFrame(() => el.classList.add('show'));
    setTimeout(() => {
      dismissToast(el);
    }, Math.max(800, ttlMs));
    return el;
  }

  function dismissToast(el) {
    if (!el || !el.isConnected) return;
    el.classList.remove('show');
    setTimeout(() => el.remove(), 200);
  }

  async function probeFilesWithLimit(files, limit = 4) {
    const results = new Map();
    let idx = 0;
    let active = 0;

    return new Promise((resolve) => {
      const next = () => {
        if (idx >= files.length && active === 0) {
          resolve(results);
          return;
        }

        while (active < limit && idx < files.length) {
          const f = files[idx++];
          active += 1;
          window.api.probeAudio(f)
            .then((info) => results.set(f, info))
            .catch(() => results.set(f, { ok: false, durationSec: 0 }))
            .finally(() => {
              active -= 1;
              next();
            });
        }
      };

      next();
    });
  }

  function showProgressUI() {
    progressWrap.style.display = 'flex';
  }

  function hideProgressUI({ preserveStatus = false } = {}) {
    resetOverallProgress();
    trackTitle.textContent = 'Track —';
    openActions.classList.add('is-hidden');
    btnOpenLogs.classList.add('is-hidden');
    if (!preserveStatus) setStatus('Ready');
  }

  function selectedPresetPolicy() {
    const selected = presetCatalog.find((p) => p.key === presetSelect.value);
    return selected?.policy || { ordering: 'input', prefixTrackNumber: false, maxTracks: null };
  }

  function describePreset(preset) {
    if (!preset) return '';
    if (preset.description) return preset.description;
    const map = {
      album_ep: 'Ideal for albums and EPs with multiple tracks in sequence.',
      single_track: 'Best for a single-song export with a quick setup.',
      long_form: 'Great for sets, podcasts, and long-form recordings.',
    };
    return map[preset.key] || '';
  }

  function updatePresetDescription() {
    const selected = presetCatalog.find((p) => p.key === presetSelect.value);
    presetDescription.textContent = describePreset(selected);
  }

  function shouldAutoSortByTrackNo() {
    if (!tracks.length) return false;
    const policy = selectedPresetPolicy();
    if (policy.ordering !== 'track_no_if_all_present') return false;
    return tracks.every((t) => t.hasTrackNo === true);
  }

  function sortTracksIfSafe() {
    if (shouldAutoSortByTrackNo()) {
      tracks.sort((a, b) => {
        if (a.trackNo !== b.trackNo) return a.trackNo - b.trackNo;
        return a.inputOrder - b.inputOrder;
      });
      return;
    }
    tracks.sort((a, b) => a.inputOrder - b.inputOrder);
  }

  function buildOutputBaseForTrack(track) {
    const base = sanitizeFileBaseName(track.outputBase || track.originalBase);
    if (!selectedPresetPolicy().prefixTrackNumber) return base;
    if (!track.hasTrackNo) return base;
    const p = pad2(track.trackNo);
    if (!p) return base;
    return sanitizeFileBaseName(`${p}. ${base}`);
  }

  let renderQueued = false;
  function scheduleRenderTrackList() {
    if (renderQueued) return;
    renderQueued = true;
    requestAnimationFrame(() => {
      renderQueued = false;
      renderTrackList();
    });
  }

  function renderTrackList() {
    trackList.replaceChildren();

    tracks.forEach((t, index) => {
      const row = document.createElement('div');
      row.className = 't-row';
      row.dataset.path = t.path;

      const no = document.createElement('span');
      no.className = 't-no';
      const trackNoText = t.hasTrackNo ? pad2(t.trackNo) : String(index + 1).padStart(2, '0');
      no.textContent = trackNoText || String(index + 1).padStart(2, '0');

      const info = document.createElement('div');
      info.className = 't-info';

      const name = document.createElement('div');
      name.className = 't-name';
      const prefixDot = t.hasTrackNo ? `${pad2(t.trackNo)}. ` : '';
      name.textContent = `${prefixDot}${t.displayName || t.originalBase}`;

      const meta = document.createElement('div');
      meta.className = 't-meta';

      const dur = document.createElement('span');
      dur.textContent = formatTrackDuration(t.durationSec);

      const sep = document.createElement('span');
      sep.className = 't-sep';

      const out = document.createElement('span');
      const outPreviewBase = buildOutputBaseForTrack(t);
      out.textContent = `${outPreviewBase}.mp4`;

      meta.appendChild(dur);
      meta.appendChild(sep);
      meta.appendChild(out);
      info.appendChild(name);
      info.appendChild(meta);

      const st = document.createElement('div');
      st.className = 't-st pending';
      st.textContent = '•';

      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 't-rm';
      removeBtn.setAttribute('aria-label', 'Remove');
      removeBtn.title = 'Remove';
      removeBtn.textContent = '✕';
      removeBtn.disabled = isRendering;

      removeBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        tracks = tracks.filter((z) => z.path !== t.path);
        trackPathSet.delete(t.path);
        sortTracksIfSafe();
        scheduleRenderTrackList();
      });

      row.appendChild(no);
      row.appendChild(info);
      row.appendChild(st);
      row.appendChild(removeBtn);
      trackList.appendChild(row);
    });

    tracksEmpty.style.display = tracks.length ? 'none' : 'flex';
    trackList.style.display = tracks.length ? 'block' : 'none';

    refreshActionState();
  }

  function clearTracksOnly() {
    tracks = [];
    trackPathSet = new Set();
    nextTrackOrder = 1;
    renderTrackList();
  }

  function clearCover() {
    imageFile = null;
    coverLabel.textContent = 'Not selected';
    coverLabel.className = 'sv dim';

    coverImg.src = '';
    coverImg.style.display = 'none';
    coverPlaceholder.style.display = 'flex';
    coverPreviewText.textContent = 'Not selected';
    coverPreviewText.className = 'cover-fname empty';
    coverDimsLabel.textContent = 'JPG · PNG · WebP';
    artBtnLabel.textContent = 'Choose cover art';

    refreshActionState();
  }

  function clearExportFolder() {
    exportFolder = null;
    exportLabel.textContent = 'Not selected';
    exportLabel.className = 'sv dim';
    folderPathLabel.textContent = 'Not selected';
    folderPathLabel.className = 'folder-path-txt empty';
    lastFinalExportFolder = null;
    refreshActionState();
  }

  function newAlbumReset() {
    if (isRendering) return;
    clearTracksOnly();
    clearCover();
    clearExportFolder();
    albumNameEl.value = '';
    presetSelect.value = defaultPresetKey;
    sortTracksIfSafe();
    scheduleRenderTrackList();
    hideProgressUI();
  }

  async function loadPresets() {
    let presets = [];
    try {
      presets = await window.api.listPresets();
    } catch {}

    if (!Array.isArray(presets) || !presets.length) {
      presets = [
        {
          key: 'album_ep',
          label: 'Album / EP — Recommended',
          description: 'Ideal for albums and EPs with multiple tracks in sequence.',
          policy: { ordering: 'track_no_if_all_present', prefixTrackNumber: true, maxTracks: null },
          recommended: true,
        },
        {
          key: 'single_track',
          label: 'Single / Track',
          description: 'Best for a single-song export with a quick setup.',
          policy: { ordering: 'input', prefixTrackNumber: false, maxTracks: 1 },
          recommended: false,
        },
        {
          key: 'long_form',
          label: 'Long-form Audio',
          description: 'Great for sets, podcasts, and long-form recordings.',
          policy: { ordering: 'input', prefixTrackNumber: false, maxTracks: null },
          recommended: false,
        },
      ];
    }

    presetCatalog = presets;
    presetSelect.replaceChildren();
    presets.forEach((preset) => {
      const opt = document.createElement('option');
      opt.value = preset.key;
      opt.textContent = preset.label;
      presetSelect.appendChild(opt);
    });

    const recommended = presets.find((p) => p.recommended) || presets[0];
    defaultPresetKey = recommended.key;
    presetSelect.value = defaultPresetKey;
    updatePresetDescription();
    sortTracksIfSafe();
    scheduleRenderTrackList();
  }

  async function pickAudios() {
    if (isValidating || isRendering || audioDialogInFlight) return;
    audioDialogInFlight = true;
    btnAddTracks.disabled = true;

    try {
      const files = await window.api.selectAudios();
      if (!files || !files.length) return;

      const newFiles = files.filter((f) => !trackPathSet.has(f));
      if (!newFiles.length) return;

      isValidating = true;
      btnNewAlbum.disabled = true;
      let validatingToast = null;
      const validatingToastTimer = setTimeout(() => {
        validatingToast = showToast('Validating audio', 'info', 999999);
      }, 180);

      try {
        newFiles.forEach((f) => trackPathSet.add(f));

        const probeResults = await probeFilesWithLimit(newFiles, 4);

        for (const f of newFiles) {
          const probe = probeResults.get(f);
          if (!probe?.ok) {
            const name = pathBasename(f);
            showToast(`Skipped unsupported file: ${name}`, 'warn', 3000);
            trackPathSet.delete(f);
            continue;
          }

          const originalBaseRaw = pathBasenameNoExt(f);
          const originalBase = stripLeadingTrackNumber(originalBaseRaw);

          tracks.push({
            path: f,
            displayName: `${originalBase} (reading tags)`,
            outputBase: originalBase,
            originalBase,
            durationSec: Math.max(0, Number(probe?.durationSec) || 0),
            trackNo: null,
            hasTrackNo: false,
            inputOrder: nextTrackOrder++,
          });
        }

        scheduleRenderTrackList();

        for (const t of tracks) {
          if (!t.displayName.includes('(reading tags)')) continue;

          try {
            const info = await window.api.readMetadata(t.path);
            const artist = (info.artist || '').trim();
            const title = (info.title || '').trim();
            const album = (info.album || '').trim();

            const tn = info.trackNo;
            const trackNo = Number.isFinite(Number(tn)) ? Number(tn) : null;
            const hasTrackNo = Number.isFinite(trackNo) && trackNo > 0;

            let outputBase = '';
            if (artist && title) outputBase = `${artist} - ${title}`;
            else if (title) outputBase = title;
            else outputBase = t.originalBase;

            t.outputBase = sanitizeFileBaseName(stripLeadingTrackNumber(outputBase));
            t.displayName = t.outputBase;
            t.trackNo = hasTrackNo ? trackNo : null;
            t.hasTrackNo = hasTrackNo;

            if (!albumNameEl.value.trim() && album) albumNameEl.value = album;
          } catch {
            t.displayName = sanitizeFileBaseName(t.originalBase);
            t.outputBase = sanitizeFileBaseName(t.originalBase);
          }

          sortTracksIfSafe();
          scheduleRenderTrackList();
        }
      } finally {
        clearTimeout(validatingToastTimer);
        dismissToast(validatingToast);
        isValidating = false;
      }
    } finally {
      audioDialogInFlight = false;
      if (!isRendering && !isValidating) {
        btnAddTracks.disabled = false;
        btnNewAlbum.disabled = false;
      }
      refreshActionState();
    }
  }

  function updateCoverMetaFromImage(fileName) {
    const ext = pathBasename(fileName).split('.').pop();
    if (coverImg.naturalWidth > 0 && coverImg.naturalHeight > 0) {
      const extLabel = ext ? String(ext).toUpperCase() : 'IMG';
      coverDimsLabel.textContent = `${coverImg.naturalWidth} × ${coverImg.naturalHeight} · ${extLabel}`;
    } else {
      coverDimsLabel.textContent = 'Image selected';
    }
  }

  async function pickImage() {
    if (isRendering || imageDialogInFlight) return;
    imageDialogInFlight = true;
    btnCover.disabled = true;
    try {
      const file = await window.api.selectImage();
      if (!file) return;

      imageFile = file;
      const coverName = pathBasename(file);
      coverLabel.textContent = coverName;
      coverLabel.className = 'sv ok';
      coverPreviewText.textContent = coverName;
      coverPreviewText.className = 'cover-fname';
      artBtnLabel.textContent = 'Change cover art';

      coverImg.onload = () => {
        coverImg.style.display = 'block';
        coverPlaceholder.style.display = 'none';
        updateCoverMetaFromImage(file);
      };
      coverImg.onerror = () => {
        coverImg.style.display = 'none';
        coverPlaceholder.style.display = 'flex';
        coverDimsLabel.textContent = 'Could not preview image';
      };
      coverImg.src = filePathToUrl(file);
    } finally {
      imageDialogInFlight = false;
      if (!isRendering) btnCover.disabled = false;
      refreshActionState();
    }
  }

  async function chooseFolder() {
    if (isRendering || folderDialogInFlight) return;
    folderDialogInFlight = true;
    btnExport.disabled = true;
    try {
      const folder = await window.api.selectFolder();
      if (!folder) return;
      exportFolder = folder;
      exportLabel.textContent = folder;
      exportLabel.className = 'sv ok';
      folderPathLabel.textContent = folder;
      folderPathLabel.className = 'folder-path-txt ok';
    } finally {
      folderDialogInFlight = false;
      if (!isRendering) btnExport.disabled = false;
      refreshActionState();
    }
  }

  async function openOutputFolder() {
    if (!lastFinalExportFolder) return;
    await window.api.openFolder(lastFinalExportFolder);
  }

  async function openLogsFolder() {
    if (!lastLogFolder) return;
    await window.api.openFolder(lastLogFolder);
  }

  function humanizeErrorMessage(raw) {
    const msg = String(raw || '').trim();
    if (!msg) return 'Export failed.';
    const firstLine = msg.split(/\r?\n/).map((x) => x.trim()).find(Boolean) || '';
    if (/cancel/i.test(firstLine)) return 'Export cancelled.';
    if (/invoke|ipc|remote method/i.test(firstLine)) return 'The app could not complete this action.';
    return firstLine.replace(/^Error:\s*/i, '');
  }

  function uiLog(event, payload = {}, level = 'info') {
    const data = (payload && typeof payload === 'object' && !Array.isArray(payload)) ? payload : {};
    const entry = { event, level, ...data };
    const verboseUiConsole = window.localStorage?.getItem('frender:ui-console') === '1';
    if (level === 'error') console.error('[ui]', entry);
    else if (level === 'warn') console.warn('[ui]', entry);
    else if (verboseUiConsole) console.log('[ui]', entry);
    try {
      window.api?.logUiEvent?.(entry);
    } catch {}
  }

  function buildReadyState() {
    return {
      hasTracks: tracks.length > 0,
      hasCover: Boolean(imageFile),
      hasExportFolder: Boolean(exportFolder),
      presetKey: presetSelect.value,
      createAlbumFolder: Boolean(createAlbumFolderEl.checked),
      isRendering,
      renderBtnDisabled: Boolean(renderBtn.disabled),
    };
  }

  function summarizeRenderPayload(payload) {
    return {
      trackCount: Array.isArray(payload?.tracks) ? payload.tracks.length : 0,
      hasCover: Boolean(payload?.imagePath),
      hasExportFolder: Boolean(payload?.exportFolder),
      presetKey: payload?.presetKey || '',
      createAlbumFolder: Boolean(payload?.createAlbumFolder),
      trackPreview: Array.isArray(payload?.tracks)
        ? payload.tracks.slice(0, 3).map((t) => pathBasename(t.audioPath || ''))
        : [],
    };
  }

  async function cancelRender() {
    if (!isRendering) return { didCancel: false, phase: 'IDLE' };
    try {
      const result = await window.api.cancelRender();
      const didCancel = Boolean(result?.didCancel);
      const phase = String(result?.phase || '').toUpperCase() || 'UNKNOWN';
      const reason = String(result?.reason || '');
      uiLog('ui.cancel_request', { didCancel, phase, reason });
      if (didCancel) {
        const status = phase === 'PLANNING' ? 'Cancelling (planning)...' : 'Cancelling...';
        setStatus(status);
      } else if (phase === 'IDLE') {
        setStatus('Nothing to cancel.', 1200);
      }
      return result;
    } catch (err) {
      uiLog('ui.cancel_failed', { message: String(err?.message || err) }, 'warn');
      setStatus('Cancel failed.', 1500);
      throw err;
    }
  }

  function updateProgressFromEngine(payload) {
    if (!isRendering) return;
    const data = (payload && typeof payload === 'object') ? payload : {};
    const phase = String(data.phase || '').toUpperCase();
    const signalRaw = String(data.progressSignal || '').toLowerCase();
    const progressSignal = ['time', 'size', 'both'].includes(signalRaw) ? signalRaw : 'none';
    lastProgressSignal = progressSignal;
    const safeTrackCount = Math.max(1, Number(data.trackCount) || renderQueue.length || 1);
    const safeTrackIndex = Math.max(0, Math.min(safeTrackCount - 1, Number(data.trackIndex) || 0));
    const name = renderQueue?.[safeTrackIndex]?.displayName || renderQueue?.[safeTrackIndex]?.originalBase || '—';
    trackTitle.textContent = `Track ${safeTrackIndex + 1}/${safeTrackCount}: ${name}`;

    if (phase === 'PREPARING') setStatus('Preparing...');
    else if (phase === 'ENCODING' || phase === 'RENDERING') setStatus('Rendering...');
    else if (phase === 'FINALIZING') setStatus('Finalizing...');

    const raw = Number(data.rawProgress);
    const hasValidRaw = Number.isFinite(raw) && raw >= 0 && raw <= 1;
    if (!hasDeterminateSignal) {
      const visualFloor = Math.min(0.15, Math.max(lastVisualProgress, readCurrentFillProgress()));
      progressDisplay = Math.max(progressDisplay, visualFloor);
      hasDeterminateSignal = true;
      totalFill.classList.remove('idle', 'done');
      applyDeterminateProgress(progressDisplay);
    }
    let target = hasValidRaw ? raw : progressTarget;
    if (!Number.isFinite(target)) target = progressTarget;
    target = Math.min(target, PROGRESS_CAP_FINISHING);
    progressTarget = Math.max(progressTarget, target, progressDisplay);
    if (phase === 'PREPARING') setStatus('Starting...');
    startProgressRaf();
  }

  function ensureRenderListeners() {
    if (disposeProgress) disposeProgress();
    if (disposeStatus) disposeStatus();

    if (typeof window.api?.onRenderProgress !== 'function' || typeof window.api?.onRenderStatus !== 'function') return;

    disposeProgress = window.api.onRenderProgress((payload) => updateProgressFromEngine(payload));

    disposeStatus = window.api.onRenderStatus(({ phase }) => {
      const normalized = String(phase || '').toLowerCase();
      if (!isRendering && normalized !== 'success') return;
      if (normalized === 'planning') {
        setStatus('Planning...');
      } else if (normalized === 'rendering') {
        setStatus('Rendering...');
        totalFill.classList.remove('idle', 'done');
        progressDisplay = 0;
        progressTarget = 0;
        applyDeterminateProgress(0);
      } else if (normalized === 'finalizing') {
        setStatus('Finalizing...');
        progressTarget = Math.max(progressTarget, PROGRESS_CAP_FINISHING, progressDisplay);
        startProgressRaf();
      } else if (normalized === 'success') {
        completeProgressNow();
        setStatus('Done');
      }
    });
  }

  window.addEventListener('beforeunload', () => {
    if (disposeProgress) disposeProgress();
    if (disposeStatus) disposeStatus();
  });

  async function renderAll() {
    const readyState = buildReadyState();
    uiLog('ui.export_click', readyState);
    if (isRendering) return;

    if (typeof window.api?.renderAlbum !== 'function') {
      const msg = 'Export failed — app API unavailable.';
      uiLog('ui.export_failed', { reason: 'render_api_missing', ...readyState, message: msg }, 'error');
      setStatus(msg, 2400);
      showToast(msg, 'warn', 3200);
      return;
    }

    if (!tracks.length) {
      const msg = 'Add audio files.';
      uiLog('ui.export_failed', { reason: 'missing_tracks', ...readyState, message: msg }, 'warn');
      setStatus(msg, 1800);
      showToast(msg, 'warn');
      return;
    }
    if (!imageFile) {
      const msg = 'Choose cover art.';
      uiLog('ui.export_failed', { reason: 'missing_cover', ...readyState, message: msg }, 'warn');
      setStatus(msg, 1800);
      showToast(msg, 'warn');
      return;
    }
    if (!exportFolder) {
      const msg = 'Choose export folder.';
      uiLog('ui.export_failed', { reason: 'missing_export_folder', ...readyState, message: msg }, 'warn');
      setStatus(msg, 1800);
      showToast(msg, 'warn');
      return;
    }

    const presetKey = presetSelect.value;
    const presetPolicy = selectedPresetPolicy();
    if (Number.isInteger(presetPolicy.maxTracks) && tracks.length > presetPolicy.maxTracks) {
      const msg = `Selected preset allows up to ${presetPolicy.maxTracks} track(s).`;
      uiLog('ui.export_failed', { reason: 'preset_max_tracks', ...readyState, message: msg }, 'warn');
      setStatus(msg, 3000);
      showToast(msg, 'warn', 3500);
      return;
    }

    const toRender = [...tracks];
    renderQueue = toRender;
    isRendering = true;
    setUiLocked(true);
    renderBtn.textContent = 'Exporting';
    cancelBtn.disabled = false;

    showProgressUI();
    resetOverallProgress();
    trackTitle.textContent = `Track 1/${Math.max(1, toRender.length)}: —`;
    openActions.classList.add('is-hidden');
    btnOpenLogs.classList.add('is-hidden');
    lastLogFolder = null;
    setStatus('Planning...');

    try {
      let finalExportFolder = exportFolder;
      if (createAlbumFolderEl.checked) {
        const safeAlbum = sanitizeFolderName(albumNameEl.value);
        finalExportFolder = await window.api.ensureDir({ albumFolderName: safeAlbum });
      }
      lastFinalExportFolder = finalExportFolder;

      const payload = {
        tracks: toRender.map((t) => ({
          audioPath: t.path,
          outputBase: sanitizeFileBaseName(t.outputBase || t.originalBase),
          trackNo: t.trackNo,
          hasTrackNo: t.hasTrackNo,
        })),
        imagePath: imageFile,
        exportFolder: finalExportFolder,
        presetKey,
        timeoutPerTrackMs: 30 * 60 * 1000,
        createAlbumFolder: !!createAlbumFolderEl.checked,
      };
      uiLog('ui.export_invoke', summarizeRenderPayload(payload));

      const res = await window.api.renderAlbum(payload);
      if (!res?.ok) {
        if (res?.error?.code === 'CANCELLED') {
          uiLog('ui.export_failed', { reason: 'cancelled', code: 'CANCELLED' }, 'warn');
          hideProgressUI({ preserveStatus: true });
          setStatus('Cancelled', 1200);
          showToast('Export cancelled.', 'warn');
        } else {
          const msg = humanizeErrorMessage(res?.error?.message || 'Unknown error');
          uiLog('ui.export_failed', {
            reason: 'render_album_not_ok',
            code: res?.error?.code || 'UNKNOWN',
            message: msg,
          }, 'error');
          hideProgressUI({ preserveStatus: true });
          setStatus('Export failed — check Logs');
          const reportFolder = pathDirname(res?.reportPath || '');
          if (reportFolder) {
            lastLogFolder = reportFolder;
            openActions.classList.remove('is-hidden');
            btnOpenLogs.classList.remove('is-hidden');
          }
          showToast(msg, 'warn', 5000);
        }
        return;
      }

      completeProgressNow();
      setStatus('Done');
      if (res?.debugLogPath) {
        const debugFolder = pathDirname(res.debugLogPath);
        if (debugFolder) lastLogFolder = debugFolder;
      }
      openActions.classList.remove('is-hidden');
      btnOpenLogs.classList.add('is-hidden');
    } catch (err) {
      const msg = humanizeErrorMessage(err?.message || err || 'Unknown error');
      uiLog('ui.export_failed', {
        reason: 'invoke_exception',
        message: msg,
        stack: String(err?.stack || ''),
      }, 'error');
      hideProgressUI({ preserveStatus: true });
      setStatus('Export failed — check Logs');
      showToast(msg, 'warn', 5000);
    } finally {
      isRendering = false;
      setUiLocked(false);
      renderBtn.textContent = 'Export';
      cancelBtn.disabled = true;
      refreshActionState();
    }
  }

  function exposeTestHooks() {
    window.__frenderTestHooks = {
      injectMockTracks(count = 50) {
        const n = Math.max(0, Number(count) || 0);
        tracks = [];
        trackPathSet = new Set();
        nextTrackOrder = 1;
        for (let i = 0; i < n; i += 1) {
          const index = i + 1;
          const p = `/tmp/mock-track-${index}.mp3`;
          trackPathSet.add(p);
          tracks.push({
            path: p,
            displayName: `Mock Track ${String(index).padStart(2, '0')}`,
            outputBase: `Mock Track ${String(index).padStart(2, '0')}`,
            originalBase: `Mock Track ${String(index).padStart(2, '0')}`,
            durationSec: 60 + index,
            trackNo: index,
            hasTrackNo: true,
            inputOrder: nextTrackOrder++,
          });
        }
        sortTracksIfSafe();
        renderTrackList();
      },
      setMockCoverAndFolder() {
        imageFile = '/tmp/mock-cover.jpg';
        coverLabel.textContent = 'mock-cover.jpg';
        coverLabel.className = 'sv ok';
        coverPreviewText.textContent = 'mock-cover.jpg';
        coverPreviewText.className = 'cover-fname';
        coverDimsLabel.textContent = '3000 × 3000 · JPG';
        artBtnLabel.textContent = 'Change cover art';
        coverImg.style.display = 'block';
        coverPlaceholder.style.display = 'none';

        exportFolder = '/tmp/mock-export';
        exportLabel.textContent = exportFolder;
        exportLabel.className = 'sv ok';
        folderPathLabel.textContent = exportFolder;
        folderPathLabel.className = 'folder-path-txt ok';

        refreshActionState();
      },
      getLayoutMetrics() {
        const tb = document.querySelector('.tb');
        const secHd = document.querySelector('.left .sec-hd');
        const firstTrack = trackList.querySelector('.t-row');
        const tracksRect = tracksBody.getBoundingClientRect();
        const rightRect = document.querySelector('.right').getBoundingClientRect();
        return {
          windowInnerWidth: window.innerWidth,
          windowInnerHeight: window.innerHeight,
          bodyOverflowX: getComputedStyle(document.body).overflowX,
          bodyOverflowY: getComputedStyle(document.body).overflowY,
          htmlOverflowX: getComputedStyle(document.documentElement).overflowX,
          htmlOverflowY: getComputedStyle(document.documentElement).overflowY,
          hasWindowVerticalScrollbar:
            (document.documentElement.scrollHeight - document.documentElement.clientHeight) > 0
            || (document.body.scrollHeight - document.body.clientHeight) > 0,
          hasWindowHorizontalScrollbar:
            (document.documentElement.scrollWidth - document.documentElement.clientWidth) > 0
            || (document.body.scrollWidth - document.body.clientWidth) > 0,
          trackListScrollable: tracksBody.scrollHeight > tracksBody.clientHeight,
          headerBottom: tb ? tb.getBoundingClientRect().bottom : -1,
          sectionHeaderTop: secHd ? secHd.getBoundingClientRect().top : -1,
          sectionHeaderBottom: secHd ? secHd.getBoundingClientRect().bottom : -1,
          firstTrackTop: firstTrack ? firstTrack.getBoundingClientRect().top : -1,
          tracksTop: tracksRect.top,
          rightTop: rightRect.top,
          trackCount: tracks.length,
        };
      },
    };
  }

  btnAddTracks.addEventListener('click', pickAudios);
  btnClearTracks.addEventListener('click', clearTracksOnly);
  btnCover.addEventListener('click', pickImage);
  coverPreview.addEventListener('click', () => {
    if (!imageFile && !isRendering) pickImage();
  });
  btnExport.addEventListener('click', chooseFolder);
  btnNewAlbum.addEventListener('click', newAlbumReset);
  btnOpenFolder.addEventListener('click', openOutputFolder);
  btnOpenLogs.addEventListener('click', openLogsFolder);
  renderBtn.addEventListener('click', renderAll);
  cancelBtn.addEventListener('click', cancelRender);
  createAlbumFolderEl.addEventListener('change', updateReleaseFolderState);
  presetSelect.addEventListener('change', () => {
    updatePresetDescription();
    sortTracksIfSafe();
    scheduleRenderTrackList();
  });

  renderTrackList();
  clearCover();
  clearExportFolder();
  updateReleaseFolderState();
  hideProgressUI();
  ensureRenderListeners();
  exposeTestHooks();
  loadPresets();
</script>

</body>
</html>
